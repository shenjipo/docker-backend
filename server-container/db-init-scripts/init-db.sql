/*
 Navicat Premium Data Transfer

 Source Server         : MySql3306
 Source Server Type    : MySQL
 Source Server Version : 80034
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80034
 File Encoding         : 65001

 Date: 23/03/2025 11:14:33
*/
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '15896302145.saA';  
FLUSH PRIVILEGES;

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `content` varchar(9999) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `author` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `createTime` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `updateTime` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `isPreviewShow` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `author_uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('09a36e1d-1f35-4f87-b661-59fcc7071457', 'vue-cli3 如何拆分打包', '[参考](https://www.cnblogs.com/leiting/p/11542608.html)\n[官方文档解释](https://webpack.docschina.org/plugins/split-chunks-plugin/)\n\n```javascript\n\n config.optimization.splitChunks({\n      chunks: \'all\',\n      maxInitialRequests: Infinity,\n      minSize: 300000, // 依赖包超过300000bit将被单独打包\n      automaticNameDelimiter:\'-\',\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name(module) {\n            const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/)[1];\n            return `chunk.${packageName.replace(\'@\', \'\')}`;\n          },\n          priority:10\n        }\n      }\n    })\n```', 'wangxing', '1708678558337', '1708678558337', '1', '213wqrffd');
INSERT INTO `article` VALUES ('09d792e8-1e1c-4664-905d-440b997fef82', '如何使用docker和docker-compose在一台虚拟机上部署多个前后端应用', '## 源码\n\n## 背景\n\n在[博客重构](http://101.133.143.249/Blog/#/PreviewPc/PreviewBlog/5f35a915-01f0-4fe3-989f-6f6bcf4712b0)中使用了docker-compose来部署一个博客的`前端+后端+数据库`，解决了应用在不同虚拟机系统上迁移部署比较繁琐的问题，但是，那篇文章使用的方法只适合部署一个前端应用和一个后端应用，如果有多个前后端应用就无法部署了，所以本文对容器结构做了进一步的优化，使得能够使用多个前后端应用的部署，新的结构图如下\n', 'wangxing', '1742305090959', '1742306834712', '2', '213wqrffd');
INSERT INTO `article` VALUES ('18c734a2-e5fb-4ea6-808a-57c18cb940fe', '个人工作台项目', '[工作台](http://101.133.143.249/workbench/#/)', 'wangxing', '1705823112714', '1705823112714', '1', '213wqrffd');
INSERT INTO `article` VALUES ('19675bb3-4171-4dfb-b78b-a350b1d19bf0', 'Nginx在同一个域名下部署多个vue应用', '# Nginx在同一个域名下部署多个vue应用(hash路由模式)\r\n假设有项目A和项目B，我们想部署在域名x.x.x.x下面，通过`http://x.x.x.x/A`能够访问到A项目的静态资源，通过`http://x.x.x.x/B`能够访问到B项目\r\n\r\n在网络搜索如何使用Nginx部署多个vue应用，多数多是这样的回答\r\n![image.png](http://8.130.116.190:3000/api/getImage/image_482900286857285.png)\r\n但是当我们按照这种方式去部署时，缺会遇到404错误，访问不到静态资源。\r\n原因在于vue脚手架的`publicPath`的默认属性是`/`，它表示以当前网站为根节点，使用绝对路径来访问项目。\r\n正确的配置方式如下。\r\n* 首先静态资源存放在如下目录\r\n![image.png](http://8.130.116.190:3000/api/getImage/image_482902217453637.png)\r\n* 接着配置nginx\r\n```shell\r\n    server {\r\n        listen       80;\r\n        listen       [::]:80;\r\n        server_name  localhost;\r\n\r\n\r\n        # Load configuration files for the default server block.\r\n        include /etc/nginx/default.d/*.conf;\r\n	// 不是根路径需要使用alias来指定静态资源位置\r\n        location /Blog {\r\n                alias   /usr/share/nginx/html/Blog/dist;\r\n        }\r\n        location /AttackSpeed {\r\n                alias   /usr/share/nginx/html/AttackSpeed/dist;\r\n        }\r\n	// 根据路使用root来指定静态资源位置\r\n        location / {\r\n                root /usr/share/nginx/html/dist;\r\n        }\r\n        error_page 404 /404.html;\r\n        location = /404.html {\r\n        }\r\n\r\n        error_page 500 502 503 504 /50x.html;\r\n        location = /50x.html {\r\n        }\r\n    }\r\n\r\n\r\n```\r\n* 最后修改vue.config.js文件，配置打包后的静态资源访问路径\r\n```javascript\r\nmodule.exports = {\r\n    lintOnSave: false,\r\n    publicPath: \'/A/\'\r\n}\r\n```\r\n打开打包后的index.html文件，确认静态资源的引入路径\r\n```html\r\n<link href=\"/A/css/chunk-04bcace8.1195e6e7.css\" rel=\"prefetch\">\r\n<script src=\"/A/js/app.708e1a3f.js\"></script>\r\n```\r\n可以看到静态资源全部通过`/A/`这个路径去引用。\r\n至此，解决了Nginx在同一个域名下部署多个应用的问题。\r\n\r\n# 补充\r\n## vite构建的应用如何配置静态资源访问路径\r\n```javascript\r\nexport default defineConfig({\r\n  plugins: [vue()],\r\n  base: \'/B/\',\r\n  server: {\r\n    host: \'0.0.0.0\',\r\n    port: 8080,\r\n    open: true\r\n  }\r\n})\r\n```\r\n**注意** 如果项目中通过相对路径引入了public目录下的图片文件，那么图片的相对路径也要加上`/A/`\r\n\r\n## 路由的修改\r\n以上的方式仅适用于hash路由模式的vue项目，如果使用hsitory模式，还需要再路由配置中加上基础路径，具体的参考链接如下：\r\n[关于Vue项目中publicPath的二三事](https://segmentfault.com/a/1190000042107272)', 'wangxing', '1695733521540', '1695733521540', '1', '213wqrffd');
INSERT INTO `article` VALUES ('28743c58-77d5-4549-9f84-1071cfa65821', 'package.josn版本号规则', '## 版本号格式\n1.1.2（主版本号.次版本号.修补版本号）\nmajor：新的架构调整，不兼容老版本\nminor：新增功能，兼容老版本\npatch：修复bug，兼容老版本\n\n## 版本号写法含义\n`1.1.2` 表示必须依赖1.1.2版\n`> 1.1.2` 表示必须大于1.1.2版\n<1.1.2，表示必须小于1.1.2版本\n### x-range\nx的位置表示任意版本\n如：1.2.x，表示可以1.2.0，1.2.1，.....，1.2.n\n\n### *-range\n任意版本，\"\"也表示任意版本\n\n如：*，表示>=0.0.0的任意版本\n\n### version1 - version2\n大于等于version1，小于等于version2\n\n如：1.1.2 - 1.3.1，表示包括1.1.2和1.3.1以及他们件的任意版本\n\n### range1 || range2\n满足range1或者满足range2，可以多个范围\n\n如：<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 < 3.0.0，表示满足这3个范围的版本都可以\n\n\n### ~version\n\n大概匹配某个版本\n\n如果minor版本号指定了，那么minor版本号不变，而patch版本号任意\n\n如果minor和patch版本号未指定，那么minor和patch版本号任意\n\n如：~1.1.2，表示>=1.1.2 <1.2.0，可以是1.1.2，1.1.3，1.1.4，.....，1.1.n\n\n如：~1.1，表示>=1.1.0 <1.2.0，可以是同上\n\n如：~1，表示>=1.0.0 <2.0.0，可以是1.0.0，1.0.1，1.0.2，.....，1.0.n，1.1.n，1.2.n，.....，1.n.n\n\n### ^version\n\n兼容某个版本\n\n版本号中最左边的非0数字的右侧可以任意\n\n如果缺少某个版本号，则这个版本号的位置可以任意\n\n如：^1.1.2 ，表示>=1.1.2 <2.0.0，可以是1.1.2，1.1.3，.....，1.1.n，1.2.n，.....，1.n.n\n\n如：^0.2.3 ，表示>=0.2.3 <0.3.0，可以是0.2.3，0.2.4，.....，0.2.n\n\n如：^0.0，表示 >=0.0.0 <0.1.0，可以是0.0.0，0.0.1，.....，0.0.n\n\n', 'wangxing', '1705824259121', '1705824462448', '1', '213wqrffd');
INSERT INTO `article` VALUES ('392b809b-d03c-407a-8b0b-f349d22301dc', '基于ts/js的前后端项目模板', '## 源码\n\n\n## 背景\n\n为了快速能够开发一个js/ts前后端项目，搭建了一个代码模板，使用了目前前后端主流的框架，实现了一个登录页面和一个菜单页面\n\n\n前端技术栈\n\n\n后端技术栈\n', 'wangxing', '1742646190658', '1742646196319', '2', '213wqrffd');
INSERT INTO `article` VALUES ('425c3528-5c39-46ca-8345-15f598206658', 'forever常见命令', '启动项目\n> forever start app.js\n\n关闭项目\n> forever stop app.js\n\n重启项目\n> forever restart app.js', 'wangxing', '1696465272101', '1696465272101', '1', '213wqrffd');
INSERT INTO `article` VALUES ('545db191-82f1-4ce2-9a24-a792197df66f', '年终总结', '1.工作台123456789\n\n本年度共完成xx个需求，新增x张卡片\n\n新增支持配置化生成卡片的能力，通过表单配置的方式生成符合卡片模型的数据，不需要写代码和发版。这种方式生成了x张卡片\n\n新增支持自动生成模板卡片的能力，通过命令行操作自动生成新卡片文件，自动更新相关导入导出文件。这种方式生成了x张卡片\n\n2.需求管理\n\n本年度共完成xx个需求，测试环境已经被云计算、资金同业、基础中台、零售、对公、数据资产团队试用，生产环境已经支持云计算、资金同业使用\n\n1.任务项动态表单重构，提升表单渲染速度\n\n动态：字段布局、字段类型、字段编辑权限、字段校验、字段关联关系、字段状态\n\n2.筛选功能扩展，支持使用js对象格式的数据编辑筛选器，无嵌套层级限制且能够支持可视化展示\n\n3.组件样式风格变更，由element-ui切换到arco-design\n\n4.新增工作台页面，新增scrum看板、活动的sprint，新增视图、看板历史记录，新增需求评审功能，新增EOA签报，\n\n5.导航菜单优化、视图、看板搜索管理优化、部分页面UI风格统一、工作流的流程图交互优化\n\n3.发布管理\n\n1.切换包管理工具，由anpm切换到npm\n\n2.集群选择优化，手工卡片分类与显示优化，\n\n3.新增手工卡片的EOA钱包与高危命令手工卡片的双人复核，新增支持galaxy部署微信小程序，新增支持ch单查询、实施完成、变更操作\n\n4.其它\n\n1.工作台、需求管理接入gopher平台，支持查看pv、uv数据\n\n2.工作台、需求管理、发布管理支持使用生产配置在本地启动，方便排查问题\n\n3.初步写了一个vscode插件工具，目前支持插件内提测（使用svm接口），使用 sst 编号提交commit信息，插件内自动间隔发起请求，sessionTick永远不会过期\n\n4.基于element-plus二次开发了一个组件库，删除了不相关的文件，目前和happy-ui一样支持通过new JsDialog()的方式打开一个弹窗。\n', 'wangxing', '1733319428434', '1734359778807', '2', '213wqrffd');
INSERT INTO `article` VALUES ('5f35a915-01f0-4fe3-989f-6f6bcf4712b0', '博客重构(docker部署+monorepo前后端一体化仓库)', '[源码地址](https://github.com/shenjipo/blog)\n\n[博客地址](http://101.133.143.249/Blog/#/Preview/PreviewBlog/5f35a915-01f0-4fe3-989f-6f6bcf4712b0)\n\n## 背景\n\n在[如何搭建并且部署一个自己的博客](http://101.133.143.249/Blog/#/Preview/PreviewBlog/997d5b4b-4e2a-43e5-b9ef-7eff375a1278)文章里，介绍了第一版的博客技术体系，但是在使用的过程中逐步发现一些问题，\n\n1. 由于使用的是云服务器，在切换不同厂商的服务器之间迁移需要配置很多开发环境，例如nginx、node、mysql等，而且可能由于linux版本不同造成兼容性问题，这浪费我们大量时间在配置环境上。\n2. 前后端仓库分离使得开发的时候需要来回切换前后端项目，且后端使用js，前端使用ts，后端开发时缺少类型校验与提示，且前后端无法使用抽象出来的一些共有的`模型`，降低开发效率\n\n## 博客技术栈\n\n前端：`vue3` `ts` `pinia` `vue-router` `vditor` `element-plus`\n\n后端：`express` `ts` `jsonwebtoken` `multer` `mysql`\n\n打包：`vite` `pnpm workspace` `rimraf` `dotenv`\n\n部署：`docker` `docker-compose`\n\n![image_eb18c628db362f1532334905b00ede46.png](http://101.133.143.249/api/getImage/image_eb18c628db362f1532334905b00ede46.png)\n\n博客的架构如图所示，最终产物是三个镜像，后端node服务镜像、前端nginx镜像与mysql镜像。基于docker-compose与这三个镜像编排生成容器实例，并且组成一个`app-network`的容器网络，这个容器网络有以下一些特点和功能\n\n* 为了用户能访问到前端静态资源，nginx容器的80端口映射到了虚拟机的80端口\n* 为了方便远程查看数据库与转移数据，mysql容器的3306端口映射到了虚拟机的3306端口\n* node可以根据容器名称去连接mysql获取数据，nginx容器可以根据容器名称转发前端网络请求到node容器\n* 为了持久化存储博客生成的图片，node容器的图片文件夹被映射到虚拟机的`/opt/blog/data/assets`文件夹\n* 为了持久化存储博客生成的mysql数据，mysql容器的图片文件夹被映射到虚拟机的`/opt/blog/data/mysql`文件夹\n\n## 基于monorepo仓库实现前后端公用一个model\n\n在[elemen-plus源码解读](http://101.133.143.249/Blog/#/Preview/PreviewBlog/748549b5-dcce-4b09-a855-f4c1b5cbd74c)介绍了基于pnpm的monorepo仓库，尤其是当前后端使用了相同的开发语言时，使用monorepo仓库能够复用部分依赖与模型，下面介绍下本博客的文件目录结构\n\n![image_cb15fb81966fce7ff4ef1230cd0bb830.png](http://101.133.143.249/api/getImage/image_cb15fb81966fce7ff4ef1230cd0bb830.png)\n\n目录中主要包含以下几个重要的文件夹\n\n* `wang-blog-client`前端源码\n* `wang-blog-server`后端源码\n* `makefile`预先定义好了一些编译打包命令，通过在命令行执行`make run`命令，在通过数字键选择，可以快速的执行命令，参考了开源项目`api-table`\n* `pnpm-workspace.yaml`多仓库配置文件，告诉pnpm，把其中指定的每个文件夹当作一个子package，每个子package都有自己的package.json文件，在执行`pnpm -F XXX npm run dev`命令或者`pnpm --filter XXX npm run dev`时，会读取xxx文件夹的package.json文件，并且在xxx文件夹下执行`npm run dev`命令\n* `blog`本项目的最终产物，包含了三个镜像、数据库脚本、数据映射的文件夹、容器编排脚本\n\n下面介绍如何实现在后端的项目中，使用前端文件夹中定义的model？\n\n1. 在后端项目中执行 `pnpm add wang-blog-client`添加前端工程（名字取前端pakcage.json部分定义的name）作为自己的依赖，结果如下图所示\n\n![image_31d0782ae98fd92191fef827639a912b.png](http://101.133.143.249/api/getImage/image_31d0782ae98fd92191fef827639a912b.png)\n\n2. 在前端项目中导出某个ts定义的model，例如在`wang-blog-client\\src\\model\\Blog.ts`文件夹下定义的\n\n```typescript\nexport interface Blog {\n    content: string,\n    title: string,\n    author: string,\n    id: string,\n    updateTime: string,\n    createTime?: string,\n    isPreviewShow: string\n}\n```\n\n3. 在后端的某个文件夹`wang-blog-server\\src\\api\\Blog.ts`下导入，导入的路径如下\n\n```typescript\nimport type { Blog } from \'wang-blog-client/src/model/Blog\'\n```\n\n至此就完成了前后端model与依赖的复用\n\n注意，在最终我们会把后端的ts文件编译成为js文件，然后把生成的js格式的文件（不包含第三方依赖）打包到node镜像，而且在node应用启动之前需要重新安装第三方依赖，由于在node容器中只有独立的后端应用，因此在使用npm i安装依赖时，会无法识别wang-blog-client这个依赖\n\n**解决方案是在制作node镜像时，需要提前手动删除pakage.json文件夹中的`\"wang-blog-client\": \"workspace:^\"`**\n\n## docker镜像的制作与使用\n\n在本项目使用`docker`与`docker-compose`工具部署时会遇到以下两个问题\n\n1. 如何持久化存储数据库的数据和用户上传的图片？\n2. 为了安全，我不想暴漏云服务器除了80和443以外的端口，那么如何将请求转发到后端服务？\n\n对于第一个问题，docker本身就提供解决方案，使用volumes把虚拟机上的某个文件夹映射到容器的文件夹，例如把本地的/data/mysql文件夹映射到容器的var/lib/mysql文件夹\n\n```yaml\nvolumes:\n  - ./data/mysql:/var/lib/mysql\n  - ./db-init-scripts:/docker-entrypoint-initdb.d/\n```\n\n对于第二个问题，docker-compose给出了解决方案，容器组网络，把nginx、node、mysql三个容器都加入一个`app-network`网络，然后使用services的名称作为域名来连接，\n\n例如后端连接mysql\n\n```javascript\nconst mysqlInstance = mysql.createConnection({\n        host: process.env.DB_HOST,\n        user: process.env.DB_USER,\n        password: process.env.DB_PASSWORD,\n        port: 3306,\n        database: process.env.DB_NAME\n    })\n```\n\n![image_d2c9a29f4d56eca44e8a5f61978777de.png](http://101.133.143.249/api/getImage/image_d2c9a29f4d56eca44e8a5f61978777de.png)\n\n前端请求后端数据，使用ng转发到后端容器，注意域名填`backend`，对应docker-compose中后端的名称\n\n```\nlocation /api/ {  \n    proxy_pass http://backend:3000/api/;   \n    proxy_set_header Host $host;  \n    proxy_set_header X-Real-IP $remote_addr;  \n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  \n    proxy_set_header X-Forwarded-Proto $scheme;  \n\n    add_header \'Access-Control-Allow-Origin\' \'*\';  \n    add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';  \n}\n```\n\n![image_a5055992348e316f6757323ac9116c2c.png](http://101.133.143.249/api/getImage/image_a5055992348e316f6757323ac9116c2c.png)\n\n至此，解决了容器部署带来的两个问题，下面时制作镜像与tar包的一些命令\n\n### nginx镜像\n\n> docker build -f Dockerfile.nginx -t blog-nginx:latest .\n\n### mysql镜像\n\n> docker build -f Dockerfile.mysql -t blog-mysql:latest .\n\n### node镜像\n\n> docker build -f Dockerfile.node -t blog-server:latest .\n\n### docker制作镜像与tar包\n\n> docker save -o ./blog/blog-nginx.tar blog-nginx:latest\n> docker save -o ./blog/blog-server.tar blog-server:latest\n> docker save -o ./blog/blog-mysql.tar blog-mysql:latest\n\n### docker加载tar包作为镜像\n\n> docker load -i blog-nginx.tar\n>\n> docker load -i blog-server.tar\n>\n> docker load -i blog-mysql.tar\n\n### docker-compose编排容器与镜像\n\n> docker-compose up 根据配置文件启动容器\n>\n> docker-compose down 根据配置文件关闭容器\n\n## 基于makefile脚本简化打包部署流程\n\n参考源码makefile文件夹\n\n## 部分docker常用命令\n\n> docker images 查看所有镜像\n>\n> docker system prune 清除所有未使用的镜像\n>\n> docker rmi xxx 删除某个镜像\n>\n> docker-compose up 根据执行命令所在目录的docker-compose.yaml配置文件启动容器\n', 'wangxing', '1729603473057', '1739884315392', '1', '213wqrffd');
INSERT INTO `article` VALUES ('68d0a13c-69db-4aa7-8334-d66abfa452c8', '为什么移动端设计开发使用@2x或者@3x的图片', '[移动端开发为什么使用@2x@3x图片](https://www.cnblogs.com/HuiTaiLang1216/p/15971286.html)\n', 'wangxing', '1700115084278', '1700115123943', '1', '213wqrffd');
INSERT INTO `article` VALUES ('6a0d8471-bdb7-493c-87a7-2545df6b76fc', '微前端框架wujie源码学习', '## 源码\n\n[wujie框架源码](https://github.com/Tencent/wujie)\n\n[wujie官方文档](https://wujie-micro.github.io/doc/)\n\n[本文源码](https://github.com/shenjipo/WuJieStudy)\n\n## 工程化部分\n\n### lerna介绍\n\nwujie使用`lerna`工具作为单一源码仓库的管理工具，其内部主要包含4个模块\n\n* wujie-core 包含了微前端业务代码，像核心的`iframe`、`shadowroot`、`html自定义组件`、`代理dom`都在里\n* wujie-vue2 封装了一个vue2组件，可以按照vue2的语法来使用wujie\n* wujie-vue3 封装了一个vue3组件，可以按照vue3的语法来使用wujie\n* wujie-react 封装了一个react组件，可以按照react的语法来使用wujie\n\n使用lerna的作用在于\n\n1. 在文件结构上隔离核心业务代码和外部组件代码，方便维护\n2. 方便本地调试，当改变了核心业务代码后无需发布，即可在组件代码中生效\n3. 方便各部分代码独立打包发布\n\n### lerna使用\n\n1. 全局或者本地安装`lerna`\n\n> pnpm install --save-dev lerna\n\n2. 进入到项目的目录下执行\n\n> lerna init\n\n生成的文件结构如图所示\n\n![image_45ad5eb091b79160cfcd8f5eae4a2fa2.png](http://101.133.143.249/api/getImage/image_45ad5eb091b79160cfcd8f5eae4a2fa2.png)\n\n3. 执行如下命令，创建两个子目录\n\n> lerna create package-a\n>\n> lerna create package-b\n\n4. 根据本文源码，修改根目录下的package.json文件，在script字段下添加一行命令，当配置了这个命令之后，如果在命令行执行`pnpm run start`命令，lerna会自动进入到各个子目录执行子目录下预先配置好的start命令，方便一键编译、启动\n\n> \"start\": \"lerna run start --parallel\"\n\n5. 修改package-a和package-b目录下的package.json文件，添加start命令\n6. 修改package-a和package-b目录下的package.json文件，引入babel包用于把ts文件编译成esm模式下的js文件\n7. 在命令行执行`pnpm run start`命令，如果在package-a和package-b文件夹的esm文件夹下出现了编译后的js文件，那么lerna就运行成功，wujie项目采用的就是上述工程化配置方案。\n\n![image_9a07efc9b05a1bc0883f84dc8e3293ad.png](http://101.133.143.249/api/getImage/image_9a07efc9b05a1bc0883f84dc8e3293ad.png)\n\n## 功能部分\n\n首先介绍下基于官方的源码调试，首先使用`pnpm i`安装依赖，然后执行`pnpm run start`启动，启动成功之后会自动弹出两个网页\n\n> http://localhost:7700/#/home\n>\n> http://localhost:8000/home\n\n根据上面工程化部分介绍，由于使用了`lerna`，修改src目录下的代码会自动触发重新编译，修改的结果可以在网页中立即看到\n\n所有的微前端框架都要解决`js`隔离和`css`隔离这两个问题，`wujie`使用iframe来解决`js`隔离问题，使用`shadowroot`解决css隔离问题，使用代理模式来把iframe中的`dom`和`winodw`的一些方法代理到`shadowroot`中去执行，在`wujie`中把`iframe`称为`js`沙箱，把`shadowroot`称为`css`沙箱，`wujie`的使用方法在官网上介绍的比较清晰，本文研究源码主要是为了弄清楚`wujie`如何实现把iframe中的操作代理到`shadowroot`中\n\n下面以 wujie-vue 组件为例说明wujie的启动过程\n\n1. 当加载wujie组件库的时候，就会创建自定义html元素 wujie-app `window.customElements.define(\"wujie-app\", WujieApp);`\n2. wujie-vue组件的模板只有一个 div 标签，当div标签按照vue2的生命周期渲染完成后，进入mounted生命周期时，调用了wujie提供的startApp方法\n3. 初始化一个wujie实例 new Wujie()，内部包含两个重要对象\n\nthis.shadowRoot  shdaowRoot实例，也就是所谓的css沙箱\n\nthis.iframe iframe实例，也就是所谓的js沙箱，此时iframe已经被插入到dom中，接着在iframeReady的回调函数中，去劫持iframe.contentWindow.Document原型链的的一些方法，例如dom操作，widnow操作，把这些操作全部代理到shaodwRoot的`proxyDocument`等属性上，而proxyDocument是被proxy的属性， 相当于在iframe内部进行的一些dom操作，实际执行在了shadowRoot中，在这个被劫持的函数中，我们还可以执行一些“副作用函数”\n\n4. wujie.active()，在dom中加入生成的shadowroot实例，并且完成shadowroot的proxyDocument的属性上方法的改写\n5. wujie.start()，加载远程js脚本，在js沙箱中执行\n\n下面提供两个手写的例子来说明简化实现上述的过程\n\n[iframe代理到shadowroot的原理](https://github.com/shenjipo/WuJieStudy/blob/master/wujie/iframe%E7%9A%84document%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%90%86%E5%88%B0shadowRoot%E4%BE%8B%E5%AD%90.html)\n\n[wujie的启动简化流程](https://github.com/shenjipo/WuJieStudy/blob/master/wujie/wujie%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A8%A1%E6%8B%9F.html)\n\n打开 `wujie启动过程模拟.html` 文件调试时需要先启动`wujie`（把官方代码git clone下来后依次执行pnpm i 和 pnpm run start即可）\n\n在控制台可以看到iframe中的**部分**dom操作确实被代理到了shadowroot中，如下图所示。\n\n![image_802dc6cded1892deeeb20520f3c48b74.png](http://101.133.143.249/api/getImage/image_802dc6cded1892deeeb20520f3c48b74.png)\n\n根据源码部分分析，如果要实现wujie的效果，代理部分特殊处理的属性和方法特别多，因此本文只做了实现原理验证，并没有完全实现把dom元素渲染到shadowroot中\n', 'wangxing', '1735730830108', '1741525341370', '1', '213wqrffd');
INSERT INTO `article` VALUES ('70ebea74-1f46-487f-bc2a-c67368091a33', '容器里的MySQL连接', 'https://github.com/zwoou/zwoou.github.io/blob/master/docker/docker%E5%AE%89%E8%A3%85mysql8.md\n容器中的mysql如何使用navicat连接\n如果navicat 提示“1045 access denied for user \'root\'@\'localhost\' ”，则执行：\n\nmysql> alter user \'root\'@\'localhost\' identified by \'root密码\';\n\n同理：如果navicat 提示“1045 access denied for user \'root\'@\'%\' ”，则执行：\n\nmysql> alter user \'root\'@\'%\' identified by \'root密码\';', 'wangxing', '1720949117655', '1720949117655', '2', '213wqrffd');
INSERT INTO `article` VALUES ('748549b5-dcce-4b09-a855-f4c1b5cbd74c', 'elemen-plus源码解读', '# 源码\n* [本项目使用的el-plus源码](https://github.com/element-plus/element-plus)\n* [mono-repo仓库demo源码](https://github.com/shenjipo/monorepo-demo02)\n* [rollup与gulp打包demo的源码](https://github.com/shenjipo/gulp-study01)\n\n**注意，使用v16.14.0版本的node，不然可能会报错**\n\n# element-plus项目整体结构\nelement-plus目录结构如图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_7e021e39-ba82-4323-a0cc-1b5ad26e7195.png)\n重点介绍几个核心的文件/文件夹\n* dist打包后的产物在这个文件夹下面，需要运行`pnpm run build`后才有，直接clone下来是没有\n* internal构建项目的脚本，配置文件在这里\n* packages 组件的源码，入口文件在这里\n* play 本地开发调试的相关文件\n* package.json 重点看`scripts`字段，这里预定义好了一些项目运行构建的脚本，\n* pnpm-workspace.yaml pnpm workspace包管理模式（mono-repo）的配置文件，告诉pnpm包管理器，当导入某些包时，到配置文件指定的目录下去解析对应的package.json文件\n相比于element-ui，element-plus没有提供太多的自动生成文件的脚本，仅仅提供了一个生成新组件文件的脚本，打包时直接读取组件目录来生成各种配置文件或者入口文件，另外，el-plus是基于vue3的，本身就是用ts写的，对类型校验、提示会更友好。\n\n\n# 基于Pnpm包管理工具的mono-repo仓库\n## mono-repo仓库功能介绍\nelement-plus使用了pnpm的workspace来管理整个项目的依赖关系，pnpm的workspace功能是mono-repo设计思想的一种实现方式，其它实现方式还有lerna等。\nmono-repo与multi-repo的优缺点对比网上比较多，总的来说对于大公司的复杂项目推荐使用mono-repo，而小的项目推荐使用multi-repo。那么在ep项目中使用了mono-repo能够实现什么功能呢？\n1. 子项目复用外部依赖--例如子项目A和子项目B同时依赖vue，那么只需要在最外层仓库安装一遍vue依赖就能够被这两个项目复用\n2. 像使用外部依赖方式一样使用别的子项目导出的函数（类）--例如在子项目app中可以直接使用如下方式导入别的项目暴漏的方法\n```javascript\n// MonoStudyProj/apps/index.ts  在此处导入别的子项目暴漏的方法，无需通过路径名，而是通过package.json中配置的name\nimport {CommonUtils} from \'@space-play/parta\'\n\n// MonoStudyProj/space-play/parta/index.ts\nexport class CommonUtils {\n    static copy(val: any) {\n        return JSON.parse(JSON.stringify(val))\n    }\n}\n```\n3. 当使用pnpm pack或者pnpm publish命令打包或者发包时，自动生成对应依赖包的版本号替换掉workspacke:*\n参考 https://pnpm.io/zh/workspaces\n\n## mono-repo仓库的一个demo\n- 本文提供一个demo来学习如何使用pnpm的workspack模式来管理一个mono-repo仓库。\n\n首先，新建一个monorepo-demo02文件夹，里面的文件结构如图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_19c7955c-6163-49ed-95cd-fb9e2b5e20a9.png)\n\npnpm-workspace.yaml文件内容如下\n```yaml\npackages:\n  - packages/*\n  - apps\n```\n上面的意思就是apps目录和packages下的子目录均为一个独立的package，pnpm会读取apps目录下的package.json和packages子目录下的package.json配置\n### 首先如果需要在apps目录里导入packages子目录里暴漏的方法，需要做两步\n1. 在apps目录下执行命令 pnpm add space-play，执行成功后，apps的package.json配置问价如图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_34005b34-8511-4e5f-a16b-b0e11a11835c.png)\n2. 在apps的任意地方均可以使用`import SpacePlay from \'space-play\'`来导入space-play包暴漏的方法，注意，import后面的包名如图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_3b88627f-f9ef-4bf3-adc0-35df45d50f0b.png)\n\n### 接着我们验证下在子项目中使用公共依赖\n1. 在**monorepo-demo02**目录下执行pnpm i vue，\n2. 在**monorepo-demo02/apps/index.ts**文件中导入vue\n```javascript\nimport { createApp } from \'vue\'\ncreateApp(App).use(SpacePlay).mount(\'#app\')\n```\n3. 在**monorepo-demo02/apps**运行`pnpm run dev`，可以正常启动\n\n### 最后验证使用pnpm pack或者pnpm publish打包时，pnpm会自动生成依赖的子项目版本号，替换掉\"workspace:^\"\n1. 在**monorepo-demo02**路径下执行`pnpm add @space-play/partb -w`其中 -w表示在根项目下安装依赖\n2. 在**monorepo-demo02**路径下执行`pnpm pack`\n生成压缩包如图\n![image.png](http://101.133.143.249:3000/api/getImage/image_9f6bf041-04d9-40e4-8c16-7b00f3adb061.png)\n\n3.打开压缩包,**monorepo-demo02/package.json**文件如图,可以看到，确实自动生成了版本号\n![image.png](http://101.133.143.249:3000/api/getImage/image_7fdcd153-5ee3-4fe3-bec7-a800abd45c92.png)\n\n# 基于rollup与gulp的自动化打包脚本\n在element-plus文件夹下执行`pnpm run build`命令，会执行构建脚本的文件，接下来介绍当我们执行这个命令时，是如何一步步生成dist下所有产物的。\n首先`pnpm run build`命令对应的实际命令如下，它表示在`element-plus/internal/build`目录下执行`pnpm run start`命令\n\"build\": \"pnpm run -C internal/build start\",\n在`element-plus/internal/build/package.json`文件下找到对应的命令如下\n> \"start\": \"gulp --require @esbuild-kit/cjs-loader -f gulpfile.ts\",\"start\": \"gulp --require @esbuild-kit/cjs-loader -f gulpfile.ts\",\n\n很显然，el-plus使用了gulp来构建了项目打包的流程，gulp主要提供了两个函数`parallel`和`series`，根据名称或者看官方文档可以知道，`parallel`提供了并行执行函数的能力,series提供了串行执行函数的能力。接着来具体看下打包的指令\n* gulp:\n这是流构建工具 gulp 的命令行接口。\n* --require @esbuild-kit/cjs-loader:\n--require 或 -r 是一个选项，允许你指定一个模块，该模块会在 gulpfile 运行之前被 require 进来。\n@esbuild-kit/cjs-loader 是一个具体的模块，用于处理 CommonJS 模块的加载。\n使用这个选项的原因是 gulpfile.ts 使用了某些 ES6+ 的特性或依赖了某些 CommonJS 模块，而直接使用 Node.js 运行可能会有问题。通过使用这个加载器，可以确保 gulpfile.ts 被正确地解释和执行。\n* -f gulpfile.ts:\n-f 或 --file 是一个选项，允许指定 gulpfile 的路径。默认情况下，gulp 会查找名为 gulpfile.js 的文件。这个文件与package.json在同级，如图所示，执行该文件中默认导出的函数 `export default`\n![image.png](http://101.133.143.249:3000/api/getImage/image_90afd893-cc57-4564-9587-86a29fb0f306.png)\n进入gulpfile.ts，默认导出的函数如下\n```javascript\nexport default series(\n    withTaskName(\'clean1\', () => run(\'pnpm run clean\')),\n    withTaskName(\'createOutput\', () => mkdir(epOutput, { recursive: true })),\n\n    parallel(\n        runTask(\'buildModules\'),\n        runTask(\'buildFullBundle\'),\n        runTask(\'generateTypesDefinitions\'),\n        runTask(\'buildHelper\'),\n        series(\n            withTaskName(\'buildThemeChalk\', () =>\n                run(\'pnpm run -C packages/theme-chalk build\')\n            ),\n            copyFullStyle\n        )\n    ),\n\n    parallel(copyTypesDefinitions, copyFiles)\n)\n```\n首先介绍下withTaskName函数与runTask函数，这两个函数最终都执行的是下面的run函数，下面以两个例子介绍下这两个函数具体的执行过程。\n1. **withTaskName(\'clean1\', () => run(\'pnpm run clean\'))** 最终的效果就是在命令行执行了pnpm run \nclean命令，注意这个命令执行时所在的路径，是项目的根目录下`projRoot`\n```javascript\nexport const run = async (command: string, cwd: string = projRoot) =>\n\n})\n```\n\n\n2. **runTask(\'buildModules\')**，这个函数的下一层如下，可以看到最终还是执行了run函数，并且传递了一个buildRoot参数，代表这个命令在`element-plus/internal/build`目录下执行，最终执行的命令是`pnpm run start buildModules`，但是查看package.json文件，我们没有找到对应的命令，实际上这里执行的是\n**gulp --require @esbuild-kit/cjs-loader -f gulpfile.ts buildModules**。\n在guplfile.ts文件最后一行有`export * from \'./src\'`，在gulpfile.ts中通过这种方式导出的函数被称为公有函数，可以通过如上命令行的方式执行此函数，在`tasks/modules.ts`文件中我们找到了buildModules函数，因此最终执行的就是这个函数。\n![image.png](http://101.133.143.249:3000/api/getImage/image_4c52ddde-87c8-41ee-aec3-f0bec8f9b1e2.png)\n```javascript\nexport const runTask = (name: string) =>\n  withTaskName(`shellTask:${name}`, () =>\n    run(`pnpm run start ${name}`, buildRoot)\n  )\n```\n\n接下来介绍具体的打包过程\n这几个打包函数具体的功能如图所示，其中生成类型文件与打包组件库文档不是重点，不做介绍\n![image.png](http://101.133.143.249:3000/api/getImage/image_43a8a44d-c8e5-45d9-8b82-fb4609d0b407.png)\nel-plus使用了rollup打包vue组件，关于rollup打包过程中具体的参数配置可以参考\n[element-plus源码与二次开发：构建与发布流程分析](https://juejin.cn/post/7257736231882407995#heading-0)\n[从ElementPlus了解如何开发一个组件库(二)](https://juejin.cn/post/7125443756291014687)\n\n也可以参考提供的demo，下面介绍一些重要的打包参数配置\n1. 如何保持打包后的目录结构与packages完全一样？\n在输出打包后的文件时，配置preserveModules与preserveModulesRoot，\n```javascript\nawait writeBundles(\n        bundle,\n        buildConfigEntries.map(([module, config]): OutputOptions => {\n            return {\n                format: config.format,\n                dir: config.output.path,\n                exports: module === \'cjs\' ? \'named\' : undefined,\n                preserveModules: true, \n                preserveModulesRoot: epRoot,\n                sourcemap: true,\n                entryFileNames: `[name].${config.ext}`,\n            }\n        })\n    )\n```\n举个例子，假设你有以下目录结构：\n![image.png](http://101.133.143.249:3000/api/getImage/image_3be83883-02e4-49c1-a66c-08c39743bd37.png)\n在你的rollup.config.js文件中，如果你设置了output.preserveModules为true，并指定preserveModulesRoot为\"src\"，那么Rollup将会把moduleA和moduleB的打包结果分别放置在以output.dir为根目录的moduleA和moduleB子目录中，而不是直接放在output.dir目录下。\n此外，还必须要配置external，排除对于第三方包的依赖，在本文提供的demo中可以尝试去掉external配置对比打包结果的变化，下面两张图反映了去掉第三方依赖后打包结果的变化。\n![image.png](http://101.133.143.249:3000/api/getImage/image_7e2e2131-e23d-4a6d-b8cb-dc306816321e.png)\n![image.png](http://101.133.143.249:3000/api/getImage/image_68234a27-cae5-4fd4-bca5-6cda288d47d0.png)\n\n\n', 'wangxing', '1717420594243', '1718523681527', '1', '213wqrffd');
INSERT INTO `article` VALUES ('762ab400-3a20-4af3-ab62-74106f4deda1', '前端工程化学习-基于element-ui与APITable', '1', 'wangxing', '1710943579015', '1710943579015', '2', '213wqrffd');
INSERT INTO `article` VALUES ('7636cbfe-8c29-4063-b3b7-1f0702fa011e', 'LuckySheet表格组件创建多个实例(iframe与微前端wujie)', '## 一.luckysheet优缺点分析\n`LcukySheet`是个基于`jQuery`开发的表格组件，其功能类似于Excel\n官方文档 \n> https://dream-num.github.io/LuckysheetDocs/zh/guide/\n\n官方github\n> https://github.com/dream-num/Luckysheet\n如果某个项目需要一个类Excel的web表格，可以基于luckysheet二次开发，其主要包含以下功能\n1. 支持**带格式的拷贝**，可以从Excel中直接拷贝内容到luckysheet表格中，不丢失格式(格式包括合并单元格、字体颜色、背景颜色、边框、居中方式、换行方式)\n2. 支持鼠标左键批量选中，支持鼠标右键属性\n3. 支持和Excel同样的方式调整列宽与行高\n\n下面是lucksheet存在的问题：\n1. 项目中各种元素的定位，包括元素事件的触发，极度依赖于id选择器，也就是说luckysheet表格从设计的时候就没有考虑过如果在一个页面内创建多个luckysheet实例，这点算是比较致命的缺陷，参考github issue \n> https://github.com/dream-num/Luckysheet/issues/1151\n\n2. 项目无法通过`npm i`方式引入，目前可以通过cdn或者本地对源码`npm run build`后引入两种方式\n\n主要介绍下解决一个页面创建多个luckysheet的解决方式，包括iframe原生隔离的方式，以及wujie微前端隔离的方式。还有如何使用html2canvas导出表格图片\n\n## 二.通过微前端(wujie)在同一个页面创建多个luckysheet实例\n首先我们通过`npm run build`的方式对源码编译打包，这样我们遇到问题能够修改源码来解决，在打包前为了适配wujie需要对源码做一些修改\n### luckysheet源码修改\n1. 根据wujie官方文档，需要显式的把lucksheet挂在到window上\n![image.png](http://8.130.116.190:3000/api/getImage/image_233dc561-1fc9-4987-bc92-a3e7e0f61fb0.png)\n\n修改文件`src/index.js`\n``` javascript\nwindow.luckysheet = luckysheet  // 这是我们需要手动加上的\nmodule.exports = luckysheet\n```\n2. wujie的js隔离是通过iframe实现的，css隔离是通过shadow-root实现的，wujie做了个代理，让iframe中的window能够对shadow-root下的元素进行操作，但是luckysheet一部分元素的定位与此发生了冲突，主要是工具栏，工具栏元素的定位主要使用了`curr.ele).offset().left`方式来获取某个元素相对于整个documnet的偏移量，但是在wujie中，使用jquey 获取shadow-root下的元素相对于视窗的偏移量全是0，因为此时的document元素在最外层（和主应用的id为app的div同级）。并不在shadow-root下面。\n修改思路 ，使用js原生的api获取元素相对于视窗的偏移量`Element.getBoundingClientRect()`\n修改文件 `src/controller/resize.js`\n```javascript\n// 446行toobarElements.forEach函数内使用到了offset的全部替换掉\n// 源代码\n    toobarElements.forEach((curr,index,arr)=>{\n        arr[index] = curr.ele;\n\n        if(index !== toobarElements.length - 1){\n            if(curr.ele instanceof Array){\n                toobarWidths.push($(curr.ele[0]).offset().left);\n            }else{\n                toobarWidths.push($(curr.ele).offset().left);\n            }\n        }else{\n            if(curr.ele instanceof Array){\n                toobarWidths.push($(curr.ele[0]).offset().left);\n                toobarWidths.push($(curr.ele[0]).offset().left + $(curr.ele[0]).outerWidth() + 5);\n            }else{\n                toobarWidths.push($(curr.ele).offset().left);\n                toobarWidths.push($(curr.ele).offset().left + $(curr.ele).outerWidth() + 5);\n            }\n        }\n\n    });\n// 修改后的\n    toobarElements.forEach((curr, index, arr) => {\n        arr[index] = curr.ele;\n\n        if (index !== toobarElements.length - 1) {\n            if (curr.ele instanceof Array) {\n\n                toobarWidths.push(document.querySelector(curr.ele[0]).getBoundingClientRect().left);\n            } else {\n                console.log($(curr.ele), document.querySelector(curr.ele).getBoundingClientRect().left, curr.ele)\n                toobarWidths.push(document.querySelector(curr.ele).getBoundingClientRect().left);\n            }\n        } else {\n            if (curr.ele instanceof Array) {\n                toobarWidths.push(document.querySelector(curr.ele[0]).getBoundingClientRect().left);\n                toobarWidths.push(document.querySelector(curr.ele[0]).getBoundingClientRect().left + $(curr.ele[0]).outerWidth() + 5);\n            } else {\n                toobarWidths.push(document.querySelector(curr.ele).getBoundingClientRect().left);\n                toobarWidths.push(document.querySelector(curr.ele).getBoundingClientRect().left + $(curr.ele).outerWidth() + 5);\n            }\n        }\n\n    });\n```\n`src/controller/menuButton.js`\n```javascript\n//  此文件全局替换18处\n// let menuleft = $(this).offset().left; \nlet menuleft = $(this)[\'0\'].getBoundingClientRect().left;\n//  此文件全局替换18处\n// mouseclickposition($menuButton, menuleft, $(this).offset().top + 25, \"lefttop\");\nmouseclickposition($menuButton, menuleft, $(this)[\'0\'].getBoundingClientRect().top + 25, \"lefttop\");\n```\n\n### wujie的使用\n\n**主应用**\n```javascript\n<div class=\"table\" ref=\"tableRef\">\n</div>\nimport { startApp } from \"wujie\";\nmounted() {\n    startApp({\n        name: this.others.count.toString(),  // 子应用唯一id\n        url: \'//localhost:8080/#/\',  // 子应用地址\n        el: this.$refs.tableRef,  // 渲染到哪个容器上\n        sync: true, \n        props: {  // 传递的参数\n            left: this.others.left,\n            top: this.others.top\n        }\n    })\n}\n```\n**子应用**\n\n```javascript\nmounted() {\n  // @ts-ignore\n  // 如果是被嵌入到wujie中，获取参数再去渲染\n  if (window.$wujie) {\n    // @ts-ignore\n    this.style.left = window.$wujie.props.left\n    // @ts-ignore\n    this.style.top = window.$wujie.props.top\n  }\n  window.luckysheet.create({\n	options // options 配置可以到luckysheet官网找\n  })\n}\n```\n### 总结\n这种方式的优点就是可以使用wujie提供的一些能力，例如父子通信比较，子应用保活等，缺点来源于luckysheet本身的设计，由于lucksheet元素定位的方式，我们无法通过控制主应用中挂在容器的位置来决定子应用的所在位置，应为luckysheet总是相对于主应用的document去定位，这个从源码上修改工作两太大，所以对于布局简单的页面，我们可以通过主应用传递给子应用定位的参数（偏移量）来控制子应用的位置，对于布局复杂的页面，还是建议使用iframe的方式来在多个luckysheet实例的情况下进行定位。iframe是浏览器原生提供的js于css沙箱，不会出现定位问题。\n\n\n## 三.通过iframe在同一个页面创建多个luckysheet实例\n1. 编译打包源码，把dist文件夹下除了index.html文件以外的文件拷贝到vue项目下的public目录，并且新建table.html文件，文件目录结构如下\n![image.png](http://8.130.116.190:3000/api/getImage/image_2f07a84b-a2e1-4802-a350-960c72cde98e.png)\n\n2. 在vue组件中通过iframe内嵌table.html文件，并且在table.html文件中引入打包后的luckysheet文件，并且初始化表格组件\n`vue`组件\n![image.png](http://8.130.116.190:3000/api/getImage/image_dfac3db1-8467-4623-8e18-26b1ec611ee6.png)\n`table.html`文件\n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n    <title>\n        <%= htmlWebpackPlugin.options.title %>\n    </title>\n\n\n    <link rel=\'stylesheet\' href=\'./LuckySheet/assets/iconfont/iconfont.css\' />\n    <link rel=\'stylesheet\' href=\'./LuckySheet/css/luckysheet.css\' />\n    <link rel=\'stylesheet\' href=\'./LuckySheet/plugins/css/pluginsCss.css\' />\n    <link rel=\'stylesheet\' href=\'./LuckySheet/plugins/plugins.css\' />\n    <script src=\"./LuckySheet/plugins/js/plugin.js\"></script>\n    <script src=\"./LuckySheet/luckysheet.umd.js\"></script>\n\n\n</head>\n\n<body>\n\n    <div id=\"luckysheet\" style=\"margin:0px;padding:0px;position:absolute;width:100%;height:100%;left: 0px;top: 0px;\">\n    </div>\n\n\n</body>\n\n<script>\n    window.onload = () => {\n        luckysheet.create(options)\n    }\n</script>\n\n</html>\n\n</html>\n\n\n```\n3. 组件通信自行搜索vue组件如何与iframe通信\n\n\n## 四.使用html2canvas以图片形式导出表格内容\n前端截图通常使用的就是`html2canvas`这个库，使用在一些特殊场景下还是有一些坑的，比如截图导出的元素中有iframe元素。\n首先，如果使用wujie来实现多个表格实例，那么导出是正常的，如果使用ifrmae实现，那么导出的时候可能会出现一篇空白，解决方案如下：\n1. 必须显式的给iframe元素设置宽和高，不能通过css设置，如下所示\n```html\n <iframe src=\"./table.html\" frameborder=\"0\" width=\"1000\" height=\"500\"></iframe>\n```\n2. 在window.onload函数中去渲染（初始化）表格，如下所示\n```javascript\nwindow.onload = () => {\n    luckysheet.create(options)\n}\n```\n3. 在html2canvas函数中设置延迟等待时间\n```typescript\nhtml2canvas(copyDom, {\n    useCORS: true,\n    allowTaint: true,\n    // 通过这个配置设置延迟截图时间\n    onclone: (canvas) => {\n        return new Promise((resolve: any, reject: any) => {\n            setTimeout(() => {\n                resolve()\n            }, 2000)\n        })\n    }\n}).then((canvas: any) => {\n    let imgUrl = canvas.toDataURL(\"image/png\");\n    let a = document.createElement(\"a\");\n    a.download = `${title}_md.png`;// 设置下载的文件名，默认是\'下载\'\n    a.href = imgUrl;\n\n    a.click();\n    a.remove(); // 下载之后把创建的元素删除\n    bodyDom.removeChild(copyDom)\n})\n}\n```\n\n原理，html2canvas在遇到iframe元素的时候，会深克隆一份这个iframe元素，并且执行window.onload函数，重新加载一次。\n\n这时候的上下文和vue组件并不是同一个上下文了，可以通过window.VUE是否存在来判断这一次是正常的初始化，还是html2canvas触发的深拷贝，深拷贝触发的时候无法通过postMessage拿到表格数据，可以在vue组件中直接把数据绑定到ifrmae属性上，然后通过window.iframe.getAttribute(\'tableData\')拿到，然后进行正常的表格初始化。\n\n由于我们需要动态的生成一些dom元素添加到div元素下面，所以还需要再html2canvas中设置延迟等待时间，等到表格渲染完成，再去转换为canvas。\n\n\n\n\n\n\n\n', 'wangxing', '1697697973588', '1698030994368', '1', '213wqrffd');
INSERT INTO `article` VALUES ('771d9208-7833-4211-a2b7-41ef76bef1f6', '基于vue的移动端斗地主小游戏开发（学习移动端开发以及ws通信）', '## 代码地址\n[前端](https://github.com/shenjipo/landlord-client)\n[后端](https://github.com/shenjipo/landlord-server)\n\n## 使用到的技术栈\n`vue3.0` `vue-router` `pinia` `浏览器原生ws` `Node.js` `服务端ws`\n\n## 实现思路\n1. 由于开始游戏后需要旋转手机屏幕，将竖屏模式变成横屏，还有全屏显示，因此使用DCloud提供的5+Runtime浏览器壳实现使用js调用android的api\n2. 游戏的业务逻辑尽量放在后端去统一处理，因为后端能够获取到所有的数据，统一处理较为方便，前端主要进行出牌逻辑的判断，包括判断牌的类型，比较牌的大小，排序。\n3. 由于需要能够实现服务端主动推送数据，所以采用浏览器原生提供的websocket，前端使用单例模式让多个页面能够共享一个ws实例,后端使用`ws`库，通过server.clients能够拿到所有当前保持连接的ws实例。客户端连接服务端时，在服务端生成这个客户端唯一的uuid，通过一个mp对象把这个uuid映射到ws实例，就能够实现像指定的客户端发送数据。\n4. 业务方面最复杂的是判断当前出牌的类型，一共有13中合法的出牌类型，获取到出牌类型后，在进行比较大小操作就比较容易。\n\n## 部分游戏画面演示\n### 匹配大厅\n![image.png](http://101.133.143.249:3000/api/getImage/image_2eb31908-a73b-42c7-beca-e29c3228cde4.png)\n\n![doudizhu1.jpg](http://101.133.143.249:3000/api/getImage/doudizhu1_759f6560-3524-481b-a05d-dafb9c3e869e.jpg)\n### 抢地主\n![image.png](http://101.133.143.249:3000/api/getImage/image_83cb8b47-53bb-4956-b39e-c4161e6d05de.png)\n![doudizhu2.jpg](http://101.133.143.249:3000/api/getImage/doudizhu2_afda5f1e-2c66-49c4-b859-cd1619fe0f28.jpg)\n### 出牌阶段\n![image.png](http://101.133.143.249:3000/api/getImage/image_430f4d61-f4b7-4c80-ad1d-f4380c4fdc50.png)\n![doudizhu3.jpg](http://101.133.143.249:3000/api/getImage/doudizhu3_be9de9fd-4953-4e5a-a20f-57c4fc433c56.jpg)\n\n## 待优化的功能\n* 时间结束后强制操作功能暂时未实现\n* 用户断网重连\n* 快速加入\n* 自动托管\n* 用户聊天\n...\n\n', 'wangxing', '1708261489015', '1708263720227', '1', '213wqrffd');
INSERT INTO `article` VALUES ('7c10c9a4-e8f4-40a0-b428-ce9d8fbc3ea4', 'chrome插件学习与开发', '## 源码\n\n[chrome插件源码](https://github.com/shenjipo/ChromeExtensions)\n\n## 目标\n\n在平时使用部分系统时，会发现有些系统页面如果一直没有任何调用接口的操作，过一段时间就会需要重新登录，其原因在于这些系统设置了随时间会自动过期的cookie，但是当每次触发cookie校验时，会重置这个过期时间。\n\n因此，可以利用这个机制，写一个`自动调用某个接口的chrome插件`，实现页面长期放置后，仍然保持登录态。\n\n## chrome插件介绍\n\n### 打包与安装方式\n\n1. chrome浏览器提供了打包插件的能力，会将源码打包成为`.crx`压缩包，将这个压缩包上传到chrome插件市场，就可以一键安装了\n2. 以开发者模式手动安装（如下图），这种方式主要用于公司内网，无法连接外网的情况\n\n![image_e78b7d18154c8ac3c19afc796d02ecce.png](http://101.133.143.249/api/getImage/image_e78b7d18154c8ac3c19afc796d02ecce.png)\n\n\n### 项目结构与manifest文件配置\n\n#### 项目结构\n\n所有的文件目录必然包含一个`manifest.json`文件，在这个文件中包含了插件的所有配置，如图\n\n![image_64fcca903d90be86ecb8ca5de1b6a2ec.png](http://101.133.143.249/api/getImage/image_64fcca903d90be86ecb8ca5de1b6a2ec.png)\n\n#### permissions配置\n\n`permissions` 主要用于声明扩展所需的功能性权限（如访问API、tabs、storage等）。\n\n**注意：**\n\n在Manifest V3中，如果你需要向网站发出请求（如通过`fetch`或`XMLHttpRequest`），你需要在 `host_permissions` 中声明目标网站的权限。`permissions` 通常不再用于指定特定网站的访问权限。\n\n```javascript\n\"permissions\": [\n    \"background\"\n],\n```\n\n`background` 权限：\n\n**作用**：允许扩展使用后台脚本来执行长期运行的任务，甚至在用户没有与扩展交互时也能运行。这个权限通常与 `background` 脚本配合使用\n\n**用途**：在后台处理一些逻辑，例如监听浏览器事件、定期检查数据等，而不需要直接与用户交互。\n\n此外，还有两个常用的配置介绍下\n\n`activeTab` 权限：\n\n**作用**：允许扩展访问当前用户正在浏览的活动标签页的内容（例如，修改页面内容或获取页面信息）。\n\n**用途**：在用户点击扩展图标时，允许扩展执行脚本或获取当前标签页的 URL、DOM 等信息。这个权限通常与 `browserAction` 或 `pageAction` 配合使用。\n\n`scripting` 权限：\n\n**作用**：允许扩展在页面中注入 JavaScript 脚本。\n\n**用途**：在 Manifest V3 中，`scripting` 权限取代了以前的 `tabs` 权限，允许你在页面中动态注入脚本。例如，使用 `chrome.scripting.executeScript` API 向当前页面注入 JavaScript 代码，或通过扩展代码操作页面的 DOM 元素。\n\n\n#### background配置\n\nbackground会指定一个js文件，chrome浏览器将在后台执行这个文件，并且常驻进程，直到浏览器关闭，它与任何一个tab页都是独立的上下文环境，可以理解为在后台执行的一个没有UI的js进程，此外在这个进程中访问浏览的资源，例如cookie或者loccalStorage是可以的，这个配置是上实现本文插件的核心配置\n\n#### host_permissions 配置\n\n`host_permissions` 用于声明扩展访问特定网页或资源的权限，通常用于网络请求或访问指定网址。\n\n常用的配置项如下\n\n* `\"http://*/*\"`: 允许访问所有以 `http://` 开头的网址。\n* `\"https://example.com/*\"`: 允许访问 `example.com` 域名下的所有页面。\n* `\"*://*/*\"`: 允许访问所有网站，无论是 `http` 还是 `https`。\n\n#### action配置\n\n在 Chrome 扩展的 `manifest.json` 文件中，`action` 是 Manifest V3 中用于配置扩展图标、工具栏按钮、弹出窗口等的关键字段。`action` 配置取代了 Manifest V2 中的 `browser_action` 和 `page_action`，使得扩展的按钮配置更加统一。\n\n用于配置扩展的工具栏按钮（即浏览器扩展图标）。在 Manifest V3 中，`action`统一了`browser_action`和`page_action` 的功能。\n\n常见的 `action` 配置项：\n\n1. **`default_icon`**: 用于设置扩展图标的默认图标，可以设置不同尺寸的图标。\n2. **`default_popup`**: 设置扩展图标被点击时弹出的 HTML 文件，可以用来创建一个简单的用户界面。\n3. **`default_title`**: 设置鼠标悬停在扩展图标上时显示的提示文本。\n', 'wangxing', '1736684619743', '1736689145732', '1', '213wqrffd');
INSERT INTO `article` VALUES ('804937c6-2d0c-4522-8888-f61816d23154', '基于next.js14搭建博客（不包括后台管理）', '## 源码地址\n> https://github.com/shenjipo/next-blog\n\n## 官方文档\nhttps://nextjs.org/docs/getting-started/installation\n\n## 安装官方脚手架，并且使用脚手架初始化项目\n**注意：next.js14要求node版本大于18.17.0，考虑到后续部署，如果使用的服务器是centos，那么要求centos版本必须大于等于8，因为node18.x以后的版本不支持centos7.x版本（可以通过额外安装2.27+版本的GLC库解决，但是非常麻烦）**\n\n安装脚手架\nnpm install -g create-next-app@14.1.0\n使用脚手架初始化项目\ncreate-next-app next-blog\n执行命令 `npm run dev`\n然后浏览器打开`locahost:3000`，看到下面这个页面说明初始化完成。\n![image.png](http://101.133.143.249:3000/api/getImage/image_3d6da4fe-114a-4775-b189-b9d05c1ac91e.png)\n\n## 博客功能设计与实现\nnext.js的特点在于提供了服务端渲染的能力，因此博客的展示页面都采用服务端渲染（不考虑后台管理页面，后台管理页面一半交互逻辑较多，且没有首屏加载速度需求，更适合采用客户端渲染）。同时考虑到兼容移动端与PC端，移动端的屏幕较小，博客的菜单需要做成可以隐藏的，因此博客的菜单按钮需要采用客户端渲染。下面介绍下next.js两大核心模块`路由`与`渲染`来实现以上的功能。\n\n### next.js的路由管理\n* next.js的路由模式使用的是**文件路径路由模式**\n打开初始化的项目，目录结构如图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_333fa8b3-80dd-435f-8805-339d0f9def2b.png)\n`src/app`目录下就是我们写业务代码的地方，访问localhost:3000，打开的页面对应`layout.tsx`文件，文件路径路由模式就是把浏览器上的访问路径映射到对应的的文件路径，例如在浏览器输入`localhost:3000/home`，其访问的页面就是图中的`layout.tsx`（当不存在layout.tsx时，访问page.tsx），浏览器路径对应的文件路径目录下必须有page.tsx或者layout.tsx，不然会报错。\n![image.png](http://101.133.143.249:3000/api/getImage/image_249244b1-d167-4a5e-a11e-951c19b7f1c3.png)\n\n* **layout.tsx**与**page.tsx**的关系\n考虑这样一种情况，我们的网站主页有个侧边栏，侧边栏上有两个模块`Home`有`About`，点击这两个模块，在右侧内容区展示相应的页面，所以对于整个页面来说，访问`locahost:3000/Home`或者`locahost:3000/About`时都需要展示这个侧边栏，那么这个侧边栏就需要写到这两个文件夹的上一级的`layout.tsx`中.\n\n此外，layout.tsx文件中默认导出的组件会接受一个children参数，这个children就是我们在page.tsx中定义的组件，我们根据自己的需要把它放在合适的位置。\n```javascript\nexport default function RootLayout({\n    children,\n}: Readonly<{\n    children: React.ReactNode;\n}>) {\n    return (\n        <html lang=\"en\">\n            <body className={inter.className}>               \n                    {children}  \n            </body>\n        </html>\n    );\n}\n```\n\n\n还有，对于有些路径，这个children不一定表示同级的page.tsx组件，而是子级的。例如，我们访问`localhost:3000/LayoutA/LayoutAB`,文件结构如图所示，`src/app/LayoutA/layout.tsx`文件内的children不会被`src/app/LayoutA/page.tsx`的内容替换，而是被`src/app/LayoutA/LayoutAB/layout.tsx`内的组件替换。\n![image.png](http://101.133.143.249:3000/api/getImage/image_9976f7d8-3d44-4ca0-b06f-58365bb2353e.png)\n\n* 动态路由规则以及参数获取\n由于服务端渲染无法设置交互事件，所以在不同博客之间的切换需要通过路由实现，通常每个博客都有自己的一个`id`，在点击博客的时候跳转到`localhost:3000/dashboard/{id}`，在next.js中，使用`[[...id]]`文件名来获取动态路由参数。例如我们要获取`localhost:3000/dashboard/336`最后路径上的参数`336`，首先需要建立如下结构的目录\n![image.png](http://101.133.143.249:3000/api/getImage/image_5ef10a91-55ed-412e-b1ea-5591db8e6919.png)\n在page.tsx中默认导出的组件会接受一个params参数，通过以下方法就能拿到路径上的参数id\n```javascript\nexport default async function Dashboard(val: { params: { id: Array<string> } }) {\n	const id = Array.isArray(val.params.id) ? val.params.id[0] : \'-1\'\n}\n```\n> tips: [...id]与[[...id]]的区别\nhttps://nextjs.org/docs/app/building-your-application/routing/dynamic-routes\n简单来说对于这个路径`localhost:3000/dashboard`仍然访问的是`src/app/dashboard/[[...id]]/page.tsx`，而[...id]无法匹配这个路径，访问的是`src/app/dashboard/page.tsx`\n\n\n根据以上路由规则，我们的blog最终目录结构如下\n`/home`是我们的主页 \n`/dashboard/[[...id]]`是博客详情页\n`api`对应的服务端接口，从数据库获取数据\n`components`包括了菜单和菜单按钮两个组件\n![image.png](http://101.133.143.249:3000/api/getImage/image_72845a67-245f-4175-83a6-943a640bff4a.png)\n\n\n### next.js的渲染模式\nnext.js提供了服务端渲染和客户端渲染两种模式，分析博客展示的需求，只有菜单按钮需要使用客户端渲染模式，因为需要添加菜单按钮的点击事件，来实现菜单的展示和隐藏，以及菜单的拖动（拖动和隐藏的实现不是本文重点，具体看代码的实现），下面介绍next.js的客户端渲染和服务端渲染适用的场景，以及使用的方法\n\n* 客户端渲染与服务端渲染使用的场景\n官网的一张图比较清晰，简单的来说，当页面需要做动态的交互进行局部dom刷新时，就需要使用客户端渲染模式\n![image.png](http://101.133.143.249:3000/api/getImage/image_6628a1b9-f64f-44a5-9778-803deb45b7fa.png)\n\n* 客户端渲染与服务端渲染的使用\nnext.js组件默认采用服务端渲染模式，可以通过在page.tsx文件的最顶端声明\n> \'use client\'\n使用客户端渲染模式。\n在服务端渲染模式下，无法使用浏览器环境下的变量(window,document)，无法使用react组件的hooks，无法使用react的类式组件，可以通过next.js内置的fetch函数去掉服务端的接口来获取渲染所需要的数据（在api目录下），客户端模式的使用和react.js本身一样，没啥区别。\n\n* 客户端组件与服务端组件的嵌套关系\n在服务端组件中，可以直接通过 import 导入客户端的组件作为自己的子组件使用，但是在客户端组件中，不能通过import导入服务端组件作为子组件。\n如果我们确实需要把服务端组件作为子组件的一部分，官网提供了一种类似插槽的方法`Passing Server Components to Client Components as Props`\n客户端组件通过参数接收子组件\n```javascript\n\'use client\'\n \nimport { useState } from \'react\'\n \nexport default function ClientComponent({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const [count, setCount] = useState(0)\n \n  return (\n    <>\n      <button onClick={() => setCount(count + 1)}>{count}</button>\n      {children}\n    </>\n  )\n}\n```\n\n把服务端组件放置在客户端组件标签内部\n```javascript\n// This pattern works:\n// You can pass a Server Component as a child or prop of a\n// Client Component.\nimport ClientComponent from \'./client-component\'\nimport ServerComponent from \'./server-component\'\n \n// Pages in Next.js are Server Components by default\nexport default function Page() {\n  return (\n    <ClientComponent>\n      <ServerComponent />\n    </ClientComponent>\n  )\n}\n```\n\n\n### MySql数据库以及ORM工具Prisma的使用\n在next.js的api文件中，提供对外的接口。接口的数据来自于各种数据库，我们使用prisma工具来生成数据库表与博客数据模型的映射，prisma屏蔽了各个数据库之间操作的差异，提供了统一的数据增删改查模式，对于前端开发比较友好。\n参考文章\n> https://www.cnblogs.com/tkuang/p/17809971.html\nhttps://134333.xyz/archives/122219441/\n\n1. 安装依赖(vscode插件商店搜索Prisma安装高亮插件)\nnpm install prisma --save\n2. 初始化prisma配置\nnpx prisma init\n\n这一步会生成.env文件和prisma文件夹，在.env文件中配置连接的数据库账号密码，数据库名称，prisma文件夹用于生成数据库各个表的ORM\n\n3. 修改.env文件\nDATABASE_URL=\"mysql://账号:密码@localhost:3306/数据库名称?schema=public\"\nDATABASE_URL=\"mysql://root:123456@localhost:3306/blog?schema=public\"\n\n4. 修改.prisma文件\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n5. 生成ORM\nnpx prisma db pull\n\n可以在prisma文件中看到数据库表对应的model\n![image.png](http://101.133.143.249:3000/api/getImage/image_039dee65-08e4-48a3-ad4c-45cfc88860af.png)\n\n6. 基于prisma客户端提供http接口\nnpm install @prisma/client\nprisma客户端使用参考 [prisma使用](https://134333.xyz/archives/122219441/)\n```javascript\nimport { NextResponse, NextRequest } from \'next/server\';\nimport { PrismaClient } from \'@prisma/client\'\nconst prisma = new PrismaClient();\nexport async function GET(request: NextRequest) {\n    let articleList = await prisma.article.findMany({\n        where: {\n            author: \'shenjipo\',\n            isPreviewShow: \'1\',\n\n        },\n        select: {\n            title: true,\n            createTime: true,\n            id: true,\n          \n        }\n    })\n    return NextResponse.json(articleList, { status: 200 });\n}\n```\n**注意，更新了数据模型后需执行npx prisma generate命令，不然ts插件检测会报错，提示不存在某个属性**\n\n### next.js的部署\n本文使用的服务器式centos8.4，安装的node版本式18.17.0，centos7.x版本无法安装node18.x版本，网上有一些解决办法，但是非常麻烦，建议升级服务器系统。\n1. 本地npm run build生成打包后的文件在.next文件夹下，把所有文件复制到服务器的`/opt/next03`目录下，\n![image.png](http://101.133.143.249:3000/api/getImage/image_b0a03070-285f-460f-af75-a4393f5caf60.png)\n执行\n2. 配置nginx\n```vim\n    server {\n        listen       80 default_server;\n        listen       [::]:80 default_server;\n        server_name  _;\n        root         /usr/share/nginx/html;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n        location /{\n                proxy_pass http://localhost:3002;\n        }\n        location /_next/static/ {\n                alias /opt/next03/.next/static/;\n        }\n        location /NextImages/{\n                alias /opt/next03/public/NextImages/;\n        }\n        location /Blog {\n                alias /usr/share/nginx/html/Blog/dist;\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n```\n重启 nginx reload -s，使得配置生效\n\n3. 启动node服务，默认3002端口(package.json里面配置)\nnpm run start \n\n\n\n\n', 'wangxing', '1710159557213', '1710338272493', '1', '213wqrffd');
INSERT INTO `article` VALUES ('8257bb7c-5f4e-4c12-a99e-60968208a262', 'Vue2的响应式原理', '# vue2\n\n## 响应式简介\n\nvue框架提供了数据的响应式能力，所谓的响应式就是当我们修改了内存的某个数据之后，vue能够自动根据某种映射关系，把这个数据的变化更新到真实的dom节点上。从直觉上来说，要实现这个功能，需要能够监听数据的变化，在数据变化时，执行一段函数就可以了，这是最基本的原理。要真正的实现这种监听还需要两个能力\n\n* **依赖收集**，一个页面上有多种数据，一个数据也可能以不同的方式展示，在页面渲染之后，框架需要能够自动生成数据与函数的依赖关系，例如数据A在页面上被两个地方以两种业务逻辑展示fun1A和fun2A，那么在页面渲染完成后，框架能够知道fun1A函数依赖数据A，fun2A函数也依赖数据A，数据A影响了fun1A和fun2A的执行结果。\n* **派发更新**，这个比较好理解，就是当A数据发生了变化之后，框架能够自动的重新执行fun1A和fun2A\n\n所以，要实现数据的响应式能力由这三种能力组成\n\n1. 数据变化的监听\n2. 依赖收集\n3. 派发更新\n\nvue2使用了Object.definePropertyapi来实现数据的监听，使用了观察者模式来实现依赖收集与派发更新。Object.defineProperty这个api已经被很多博客介绍过了，理解起来比较容易，本文不做介绍。而如何使用观察者模式来实现自动依赖收集与派发更新是vue的一个核心技术点，很多文章讲的比较模糊，而且没有提供简化的能够上手调试的demo，因此本文重点介绍vue如何使用观察者模式实现自动依赖收集与派发更新\n\n### 观察者模式\n\n在设计模式还有一种设计模式叫发布-订阅模式，这种模式和观察者模式有一定的相似之处，对比学习能够更好的理解观察者模式的作用与使用的场景。\n![image.png](http://101.133.143.249:3000/api/getImage/image_593f891a-d507-41d5-bef4-e73682919717.png)\n如上图所示，发布订阅模式相比观察者模式多了一个Topic Event（事件注册中心），Publisher和subscriber的关联关系需要通过Topic Event来间接进行，publisher和subscriber属于弱耦合状态，publisher不知道自己发布的主题被哪些subscriber订阅，而subscriber也不知道自己订阅的topic是被谁发布的。在观察者模式中，Watcher和dep是强耦合关系，观察者知道自己所有观察的对象，被观察者也知道自己被哪些Watcher观察了。\nvue选择了观察者模式原因是为了性能优化，能够细粒度的更新视图，例如\n\n```javascript\nnew Vue({\n    data: {\n        nameList: [\'wang\'],\n        age: 22,\n    }\n})\n```\n\n某个render watcher依赖了age(后面会介绍什么是render watcher)，vue希望只有age发生变化时去通知render watcher更新，而namelist变化时不去更新。因此能够相互直接影响的观察者模式更适合用户处理这种关系。发布订阅其实也可以，但是由于publish和subscriber总是通过Topic Event来间接影响做起来更麻烦。\n\n### 依赖收集\n\n依赖收集的过程如下图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_6e413c9f-c534-4329-9f4b-368abf9ce9df.png)\n\n1. Observe(data)，使用Object.defineproperty api重写用户定义数据的get和set方法，在get方法中收集watcher依赖，在set方法中触发watcher更新\n2. 初始化一个watcherA，在watcher内部有一个对象deps保存了这个watcher所有依赖的数据\n3. 计算watcher的value，这一步`render watcher` `computed watcher` `watch wathcer`的具体实现有所区别，但是所有watcher在计算value的第一步都是先执行pushTarget\n4. pushTarget，这一步把第2步生成的watcher实例插入watcher栈，并且挂载到一个全局对象Dep.target上，方便这个watcher依赖的数据收集\n5. 依赖收集，在计算三种watcher值的过程中，会触发所依赖的数据被重写的get方法，在get方法中收集watcherA\n6. 收集依赖结束，把watcherA出栈，并且把全局的Dep.target置为null\n   最终可以看到在watcherA内部的deps数组保存了objA.__ob__，在objA.__ob__的subs数组里保存了watcherA，这样观察者和被观察者都能直接影响对方，方便依赖的更新与派发\n\n### 派发更新\n\n派发更新的过程如下图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_64109d98-cd41-4711-be6d-b39689243d16.png)\n假设有三个render Watcher,watcher1依赖了objA，watcher2依赖了objA和objB，watcher3依赖了objB，在完成了依赖收集后，被观察的数据objA和objB知道哪些watcher在观察自己，当数据objA发生了变化时，触发了重写的set方法，通知对应的watcher重新计算value\n\n## 3种watcher介绍\n\nvue总共有三种类型的watcher，\n\n* render watcher 渲染watcher，主要用来计算页面上{{}}内部的值\n* computed watcher 计算属性 watcher，主要用于用户定义的computed\n* watch watcher 数据监听 watcher，主要用户用户定义的watch\n  这三种watcher的响应式原理总体上一样，都是基于观察者模式+数据监听，但是在具体功能上有所区别，其中render watcher是最基础的watcher，computed watcher为了实现`当数据没有发生变化时，不重新计算而是用缓存`而实现了一套懒更新，watch watcher在初始化时传入的expOrFn不是一个函数而是一个字符串，需要利用parsePath把这个字符串转换成一段函数，在计算value时候执行，保证能够触发watcher的对象收集依赖，此外，在更新value时候，需要同时项cb函数传入newValue和oldvalue。\n  最后vue在被观察者的层面屏蔽了三种watcher的差异，提供了统一的update方法来更新watcher。\n\n## 三种watcher的仿vue手写实现\n\nvue实现响应式的细节很多，而且考虑了很多场景，下面是部分功能的手写实现\n\n1. [render watcher基础响应式手写实现](https://github.com/shenjipo/vue-study/blob/master/1.reactive(1.base).html)\n2. [render watcher新增监听键值对新增的响应式实现](https://github.com/shenjipo/vue-study/blob/master/1.reactive(2.%E5%AF%B9%E8%B1%A1%E9%94%AE%E6%96%B0%E5%A2%9E%E5%88%A0%E9%99%A4key%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F).html)\n3. [render watcher数组7种方法的响应式实现](https://github.com/shenjipo/vue-study/blob/master/1.reactive(3.%E6%95%B0%E7%BB%84reactive).html)\n4. [computed watcher基础响应式实现](https://github.com/shenjipo/vue-study/blob/master/3.computed(1.base).html)\n5. [computed watcher更新依赖实现](https://github.com/shenjipo/vue-study/blob/master/3.computed(2.%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E6%9B%B4%E6%96%B0%E4%BE%9D%E8%B5%96).html)\n6. [computed watcher依赖了computed watcher实现](https://github.com/shenjipo/vue-study/blob/master/3.computed(3.%E4%BE%9D%E8%B5%96%E4%BA%86%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7).html)\n7. [watch watcher基础响应式实现](https://github.com/shenjipo/vue-study/blob/master/4.Watch(1.base).html)\n\n## vue2无法实现响应式的若干情况\n\n\n## vue2部分源码设计原因\n\n### vue内部为什么有两种Dep实例，一种是闭包，一种是对象上的__ob__?\n\n为了实现对象属性添加与删除的响应式\n\n### 为什么vue不允许在组件内部的data对象上动态的添加响应式数据？\n\n同上，因为vue没有实现对于对象新增、删除属性的监听，而且对于根data对象，没有生成对应的dep实例，\n\n### 那么为什么非根data对象可以通过this.$set实现动态添加响应式的数据，怎么实现的？\n\n利用了对象上的dep实例，即xx.__ob__\n', 'wangxing', '1697698013307', '1732199740798', '1', '213wqrffd');
INSERT INTO `article` VALUES ('87eaed2d-9dbb-4020-a6a3-b5e7e8bef143', 'asfsaf', '123', 'wangxing', '1696418685891', '1702877889691', '2', 'e8e54989-296c-45f1-a67f-f60b2986cf8f');
INSERT INTO `article` VALUES ('8abd0201-340f-4f2c-a1a5-aaaff397ed05', '部分平台账号密码', '## 留学服务认证\n\nhttps://lxyzt.cscse.edu.cn/index\n\n19858108583\n\n15896302145.saA\n\n## 国家政务服务app\n\n19858108583\n\n15896302145sa\n\n## 京东锦鲤\n\n机构号 JX01102706\n\n账号 WANGXING446\n\n密码 011410\n\n\n## 论坛\n\nhttps://moxing.app/\n\nshenjipo\n\n15896302145.saA\n\n\nhttps://www.qinglanhua.com/\n\n解压密码：\n\nqinglanhua.net\n', 'wangxing', '1731206934713', '1737174275760', '2', '213wqrffd');
INSERT INTO `article` VALUES ('91e849a3-bb34-462c-b155-e21a20c663d1', 'vue3的响应式原理', '## 源码\n\n[本文源码-基于vue3.5](https://github.com/shenjipo/vue-study)\n\n## 响应式原理\n\n在[vue2的响应式原理](http://101.133.143.249/Blog/#/MainPage/BlogUpdate/8257bb7c-5f4e-4c12-a99e-60968208a262)中介绍了要实现数据的响应式，需要满足三个条件\n\n* 数据变化的监听\n* 依赖自动收集\n* 派发更新\n\n在vue3.5这个版本，除了对于基本数据类型的监听仍然使用`Object.defineProperty`实现，其它部分都做了重构，首先对于非基本数据类型的监听使用了`Proxy`与`Reflect`api实现，vue3.x的任意版本都是基于此，对于依赖的自动收集和派发更新，vue3.5引入了二维双向链表并结合观察者模式、发布订阅模式来实现\n\n## 基本数据类型的响应式实现\n\n由于`Proxy`只能实现对象类型数据的代理，所以对于基本数据类型的响应式，vue3使用了ES6的`class get set`来实现，其底层还是和vue2一样的`Object.defineProperty`，这一块有很多文章介绍过，本文不做介绍，重点讲一下vue3.5如何使用二维的双向链表这种数据结构来实现自动收集依赖与派发更新\n\n### 响应式涉及的三个class\n\nvue3.5的响应式涉及三个主要的class\n\n* Dep\n* Link\n* ReactiveEffect\n\n类比vue2的观察者模式，Dep是被观察的对象，ReactiveEffect是观察者，在vue3中被称为副作用函数（下面介绍时成为Sub），我们的目标是系统能够自动的建立起数据和相关副作用函数之间的联系，当数据发生变化时，通知相关的副作用函数去执行，然后更新依赖关系，Link就是用来连接Dep和Sub之间的桥梁，下图展示了Dep、Sub和Link之间的依赖关系，使用的链表结构实现\n\n![a0da09f5e6317ccdfde1574ac3c3c0e4_b006f6f8369e59f3c03c9c72b92d2288.png](http://101.133.143.249/api/getImage/a0da09f5e6317ccdfde1574ac3c3c0e4_b006f6f8369e59f3c03c9c72b92d2288.png)\n\n根据上图，vue3.5的响应式系统会把Sub节点放在x轴链表的头部，把Dep节点放在y轴链表的头部，其它位置都是Link节点，\n\nDep节点包含以下几个重要的属性\n\n```javascript\nclass Dep{\n        constructor() {\n            // 用来控制更新链表\n            this.version = 0;\n            this.activeLink = void 0;\n            // 指向link链表的尾部节点\n            this.subs = void 0;\n            // 指向link链表的头部节点\n            this.subsHead = void 0;\n        }\n}\n```\n\nLink节点包含以下几个重要的属性\n\n```javascript\nclass Link{\n        constructor(sub, dep) {\n            this.name = new Date().getTime()\n            // watchEffect函数\n            this.sub = sub;\n            // 依赖的数据\n            this.dep = dep;\n            // 指向Link链表的后一个节点（X轴）nextLink\n            this.nextDep = void 0\n            // 指向Link链表的前一个节点（X轴）prevLink\n            this.prevDep = void 0\n            // 指向Link链表的下一个节点（Y轴）\n            this.nextSub = void 0\n            // 指向Link链表的上一个节点（Y轴）\n            this.prevSub = void 0\n            // 用于判断当前link和dep还是否保持响应式关系\n            this.version = dep.version\n        }\n}\n```\n\nSub节点包含以下几个重要的属性\n\n```javascript\nclass ReactiveEffect{\n        constructor(fn) {\n            // 副作用函数\n            this.fn = fn;\n            // 指向链表的头部节点\n            this.deps = void 0;\n            // 指向链表的尾部节点\n            this.depsTail = void 0;\n        }\n}\n```\n\n### 自动收集依赖、更新依赖的过程\n\n下面以一个例子来说明这三个类之间是如何相互调用，实现自动收集依赖、更新依赖\n\n假设有3个响应式变量和一个副作用函数\n\n```javascript\nconst name1 = ref(\'a\')\nconst name2 = ref(\'b\')\nconst flag = ref(true)\nconst effect1 = new ReactiveEffect(() => {\n    let temp = \'\'\n    if (flag.value) {\n        temp = name1.value\n    } else {\n        temp = name2.value\n    }\n})\neffect1.run()\n```\n\n首先，当新建了ReactiveEffect的实例后，会调用run方法，自动执行传入的副作用函数，如果副作用函数内部有响应式变量，会触发该变量被劫持的get函数，在get函数内部，使用dep实例进行依赖收集\n\n下面用几张图来说明二维双向链表的建立过程，可以结合[1.watchEffect(2.手写reactiveEffect基础数据类型，自动收集、更新依赖)](https://github.com/shenjipo/vue-study/blob/master/vue3/1.watchEffect(2.%E6%89%8B%E5%86%99reactiveEffect%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%94%B6%E9%9B%86%E3%80%81%E6%9B%B4%E6%96%B0%E4%BE%9D%E8%B5%96).html))比较容易理解，\n\n![image_86fddf2282bac8668fb0dfbfb30ee5a4.png](http://101.133.143.249/api/getImage/image_86fddf2282bac8668fb0dfbfb30ee5a4.png)\n\n当执行了effect1.run之后，首先link的sub指向effect1，dep指向了依赖项dep(flag)\n\n![image_d5ed4a4e10895db8eae4b3533e5a636f.png](http://101.133.143.249/api/getImage/image_d5ed4a4e10895db8eae4b3533e5a636f.png)\n\n接着更新sub(effect1)的节点指向\n\n![image_b1730534ad2f222f62eee4c0b66c0cf4.png](http://101.133.143.249/api/getImage/image_b1730534ad2f222f62eee4c0b66c0cf4.png)\n\n接着更新dep(flag)的节点指向\n\n![image_6b686c6c5a563148ac01f314a7b57918.png](http://101.133.143.249/api/getImage/image_6b686c6c5a563148ac01f314a7b57918.png)\n\n副作用函数继续执行，触发了dep(a)收集依赖，各个节点指向的更新如上图所示\n\n![image_b66efffa784bfa2682cf0f97fafd4fb6.png](http://101.133.143.249/api/getImage/image_b66efffa784bfa2682cf0f97fafd4fb6.png)\n\n当我们执行了flag.value = false时，自动重新执行副作用函数，执行之前，先根据链表指向把sub所在y轴的所有link节点version设置为-1，执行过程中，回去更新对应link的version，当结束时，如果仍然有link的version为-1，那么这个link节点需要从链表移除\n\n![image_ff160d9d76b757aa1fe81f13ad1d56c1.png](http://101.133.143.249/api/getImage/image_ff160d9d76b757aa1fe81f13ad1d56c1.png)\n\n新加入了dep(b)依赖项，各个链表节点指向更新如图所示\n\n![image_356686621eda822193ca5da0999319ba.png](http://101.133.143.249/api/getImage/image_356686621eda822193ca5da0999319ba.png)\n\n最后，清楚version为-1的link节点，也就是中间一个，可以看到没有任何节点再指向此link\n\n至此，完成了自动收集依赖与更新依赖\n\n### 多个dep依赖多个sub时如何收集依赖、更新依赖\n\n下面以一个例子来说明这三个类之间是如何相互调用，实现多个dep依赖多个sub时如何收集依赖、更新依赖\n\n假设有2个响应式变量和2个副作用函数\n\n```javascript\n// 第二个参数用于调试，和响应式实现无关\nconst name1 = ref(\'wang\', \'name1\')\nconst name2 = ref(\'xing\', \'name2\')\n\nconst effect1 = new ReactiveEffect(() => {\n    console.log(\'ReactiveEffect1\')\n    const res = name1.value + name2.value + \'1\'\n}, \'effect1\')\nconst effect2 = new ReactiveEffect(() => {\n    console.log(\'ReactiveEffect2\')\n    const res = name1.value + name2.value + \'2\'\n}, \'effect2\')\neffect1.run()\neffect2.run()\n```\n\n当新建了ReactiveEffect的实例后，会调用run方法，自动执行传入的副作用函数，如果副作用函数内部有响应式变量，会触发该变量被劫持的get函数，在get函数内部，使用dep实例进行依赖收集，结合更好理解\n\n下面用几张图来说明二维双向链表的建立过程，可以结合[1.watchEffect(3.手写reactiveEffect基础数据类型，多个sub依赖多个dep)](https://github.com/shenjipo/vue-study/blob/master/vue3/1.watchEffect(3.%E6%89%8B%E5%86%99reactiveEffect%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A4%9A%E4%B8%AAsub%E4%BE%9D%E8%B5%96%E5%A4%9A%E4%B8%AAdep).html)比较容易理解，\n\n图片请参考[参考文章-看不懂来打我！让性能提升56%的Vue3.5响应式重构](https://mp.weixin.qq.com/s/_KQyb9cQv-r-tR2gTT0ZCQ)\n\n依赖触发过程比较简单，有了上面的链表结构，可以通过`Dep1`的`subs`属性指向队列的尾部，也就是指向`Link3`。`Link3`中可以直接通过`sub`属性访问到订阅者`Sub2`，也就是第二个`watchEffect`，从而执行第二个`watchEffect`的回调函数。接着就是使用Link的`preSub`属性从队尾依次移动到队头，从而触发`Dep1`队列中的所有Sub订阅者。\n\n## 非基本数据类型的响应式实现\n\nvue3对于非基本数据类型数据的get和set劫持通过`Proxy`和`Reflect`api实现，`Proxy`本身也只能实现对象的浅层代理，因此与vue2类似，需要再get方法中判断子属性是否仍然为一个对象，然后去递归代理\n\n实现的思路如下，具体细节可以参考[2.watchEffect(4.手写reactiveEffect对象数据类型，自动更新依赖)](https://github.com/shenjipo/vue-study/blob/master/vue3/2.watchEffect(4.%E6%89%8B%E5%86%99reactiveEffect%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E4%BE%9D%E8%B5%96).html)\n\n```javascript\nfunction reactive(target){\n    const proxy = new Proxy(target,{\n        get(target,key,receiver){\n              // 收集依赖\n              track(target, key)\n              const res = Reflect.get(target,key,receiver)\n              // 递归实现响应式\n              if (isObject(res)) {\n                  return reactive(res);\n              }\n              return res\n        }\n        set(target,key,newValue,receiver){\n              const oldValue = target[key]\n              // 触发依赖\n              trigger(target,key,newValue,oldValue)\n              return Reflect.set(target,key,newValue,receiver)\n        }\n    })\n    return proxy\n}\n```\n\n可以看到，实现的思路与vue2高度相似，利用`Proxy`api劫持对象的get和set方法，在get方法中调用`track`函数收集依赖，在trigger函数中调用`trigger`函数触发副作用函数，需要注意的是，在处理依赖项dep时，与vue2略有不同\n\nvue2中为了实现对象属性添加和删除的响应式，有两种dep实例，闭包中的dep以及挂在在对象的`__ob__`键上的dep实例，而`Proxy`api本身能够实现监听键值的增加与删除，因此，不需要两种dep实例，而是使用了一个全局的`WeakMap`对象来保存dep实例，例如对于如下一个响应式对象\n\n```javascript\nconst p1 = ref({\n    name: \'a\', \n    child:{name: \'b\'}\n})\ntargetMap.set(p1, new Map())\nconst dep = targetMap.get(p1)\ndep.set(\'name\', new Dep())\ndep.set(\'child\', new Dep())\n// 递归第二层\ntargetMap.set(p1.child, new Map())\nconst dep = targetMap.get(p1.child)\ndep.set(\'name\', new Dep())\n```\n\n![image_90048b6a5446efb9d082809804bf0f72.png](http://101.133.143.249/api/getImage/image_90048b6a5446efb9d082809804bf0f72.png)\n\n可以看到，从整个对象开始，每一层非基本数据类型的对象数据必然有一个`Map`与之对应，通过全局的`targetMap`来维护`Map`，然后通过每一个对象的`Map`来维护每个key对应的`dep`，设计的非常简洁，从而很方便的**更新**或者**获取**某个key对应的dep实例，通过dep实例我们就可以按照自动收集依赖，构建前面介绍的二维链表结构，然后基于这个二维链表结构在`trigger`函数中触发对应的副作用函数\n\n### 为什么ref生成的响应式数据需要.value而reactive不需要？\n\nref实现的响应式对于数据第一层的监听是通过`Object.defineProperty`劫持了xxx.value的get和set方法，而reactive通过`Proxy`实现了对于源对象的代理，不需要劫持特定key的get和set方法\n\n## 参考文献\n\n[参考文章-看不懂来打我！让性能提升56%的Vue3.5响应式重构](https://mp.weixin.qq.com/s/_KQyb9cQv-r-tR2gTT0ZCQ)\n', 'wangxing', '1733230494620', '1734360457391', '1', '213wqrffd');
INSERT INTO `article` VALUES ('955631a2-94cf-4c9e-8029-9decaf04c079', '测试图片', '![image.png](http://localhost:3000/api/getImage/image_485711523446853.png)', 'wangxing', '1696418716540', '1696463392965', '2', '213wqrffd');
INSERT INTO `article` VALUES ('997d5b4b-4e2a-43e5-b9ef-7eff375a1278', '如何搭建并且部署一个自己的博客(以阿里云服务器centos7.5部署为例)', '# 如何搭建博客\n## 博客源代码\nweb端 \n> https://github.com/shenjipo/MyBlog-Client\n\n使用的技术\n`vue3` `ts` `arco-design(组件库)` `mavon-editor(md编辑器)` `axios(网络通信)`\n \n服务端 \n> https://github.com/shenjipo/MyBlog-Server\n\n使用的技术\n`node.js` `express(node服务端web框架)` `express-jwt与jsonwebtoken(jwt登陆)` `sqlite3(数据库中间件)` `multer(图片服务中间件)`\n\n参考的教程\n> https://www.bilibili.com/video/BV1t3411F7VH/?spm_id_from=333.337.search-card.all.click&vd_source=303d21caff999a67465b742cc22bf109\n\n\n## 部署\n## 前端部署\n### 打包构建\n前端部署需要使用到Nginx服务，首先第一步是打包构建，输出产物到dist目录下，vue脚手架基本已经配置好了，我们只需要执行npm run build，我们需要注意的是区分生产环境和测试环境，这两种环境下的后端请求地址不一样，一半通过.env配置文件来解决。\n前端项目有.env.development和.env.production两个文件，通过配置打包参数，可以读取指定的配置文件，内容如下\n```javascript\n// .env.development文件\nNODE_ENV = \'development\'\nVUE_APP_BASE_API = \'http://localhost:3000/api\'\n```\n```javascript\n// .env.production文件\nNODE_ENV = \'production\'\nVUE_APP_BASE_API = \'http://101.133.143.249:3000/api\'\n```\n```javascript\n// package.json文件\n\"serve\": \"vue-cli-service serve --mode development\",\n\"build\": \"vue-cli-service build --mode production\",\n//代码中使用\nconst service: AxiosInstance = axios.create({\n    baseURL: process.env.VUE_APP_BASE_API,\n    timeout: 30000\n})\n```  \n\n### 如何安装nginx(待补充)\nyum install nginx\n启动nginx\nsystemctl enable nginx\nsystemctl start nginx\n\n### 如何配置nginx（多项目的Nginx配置）\nnginx配置文件默认路径\n> /etc/nginx/nginx.conf\n![image.png](http://101.133.143.249:3000/api/getImage/image.png)\n\n配置文件内容，最终实现效果,通过 http://xxx.xxx.xxx.xxx/访问到的是Blog的静态资源，通过http://xxx.xxx.xxx.xxx/Blog访问到的是Blog的静态资源，通过http://xxx.xxx.xxx.xxx/AttackSpeed访问到的是AttackSpeed的静态资源。\n```shell\nserver {\n    listen       80;\n    listen       [::]:80;\n    server_name  localhost;\n    # Load configuration files for the default server block.\n    include /etc/nginx/default.d/*.conf;\n    location /Blog {\n            alias   /usr/share/nginx/html/Blog/dist;\n     }\n     location /AttackSpeed {\n            alias   /usr/share/nginx/html/AttackSpeed/dist;\n     }\n     location / {\n            root /usr/share/nginx/html/Blog/dist;\n     }\n     error_page 404 /404.html;\n     location = /404.html {\n     }\n\n     error_page 500 502 503 504 /50x.html;\n     location = /50x.html {\n    }\n}\n```\n静态资源目录上传到对应的文件夹下\n> /usr/share/nginx/html/Blog/dist;\n /usr/share/nginx/html/AttackSpeed/dist;\n\n**注意，修改配置文件后必须重启nginx才能生效，重启命令如下**\n> nginx -s reload\n\n**注意，到此虽然配置完成，还必须主动开启阿里云的80端口才能通过http访问到对应的前端页面(开启端口在后端部署会讲到)**\n\n## 后端部署\n为了避免版本不一致造成的问题，服务器的node、npm版本以及其它安装包的版本需要和本地保持一致\n### 通过yum安装指定版本的node(以14.17.0为例)\n首先查看本地node的版本\n> node -v\n1. 添加NodeSource仓库：\n首先，使用以下命令添加NodeSource仓库，并将其配置为安装Node.js 14.x版本：\n> curl -fsSL https://rpm.nodesource.com/setup_14.x | sudo bash -\n2. 安装Node.js：\n一旦添加了仓库，你可以使用Yum安装Node.js 14.17.0版本：\n> yum install -y nodejs-14.17.0\n3. 验证安装：\n安装完成后，你可以运行以下命令验证Node.js版本：\n> node -v\n### 安装开发依赖包(sqlite3中间价需要重点关注)\n本后端项目的`node_modules`包较少，有人可能会直接把本地的`node_modules`包复制到服务器对应的地方，如果你本地的环境和服务器环境不一致（例如本地使用windows开发，服务端使用linux），其中sqlite3安装包一定会出现问题，该问题链接如下\nhttps://www.saoniuhuo.com/question/detail-2645160.html\n其现象与原因如下\n> 无法找到模块“/home/container/node_modules/sqlite3/lib/binding/napi-v3-linux-x64/node_sqlite3.node\n> SQLite3需要一个特定于目标系统架构的库。如果你安装了npm包，它会尝试从源代码构建这个库，“活”在目标机器上。如果目标系统没有安装必要的C编译器和构建工具，则此操作可能会失败。\n简单的来说，就是在windows上通过npm安装的sqlite3包无法在linux上使用，因为它需要运行时构建\n\n解决方案就是在linux环境中重新执行一遍安装命令\n> npm i\n\n即使在linux上通过npm安装了对应sqlite3包，仍让会出现如下的问题\n> /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.8‘ not found\n该问题是由于gcc版本太低，缺少了相应的库文件导致的，可以通过如下命令查看前Linux服务器gcc版本中包含哪些库\n> strings /usr/lib64/libstdc++.so.6 | grep GLIBC\nstrings /usr/lib64/libstdc++.so.6|grep CXXABI\n\n解决方案，下载最新版本libstdc.so_.6.0.26，删除原来的软连接，建立新的软连接\n```shell\ncd /usr/local/lib64/\n// 下载最新版本的`下载最新版本的libstdc.so_.6.0.26\nwget http://www.vuln.cn/wp-content/uploads/2019/08/libstdc.so_.6.0.26.zip\n// 解压\nunzip libstdc.so_.6.0.26.zip\n// 将下载的最新版本拷贝到 /usr/lib64\ncp libstdc++.so.6.0.26 /usr/lib64\ncd  /usr/lib64\n// 查看 /usr/lib64下libstdc++.so.6链接的版本\nls -l | grep libstdc++\n// 删除原先的软连接(不放心可以备份)\nrm libstdc++.so.6\n// 使用最新的库建立软连接\nln -s libstdc++.so.6.0.26 libstdc++.so.6\n// 查看新版本，成功\nstrings /usr/lib64/libstdc++.so.6 | grep GLIBCXX\n\n参考链接：https://blog.csdn.net/jaber_chen/article/details/124715913\n```\n### 通过node或者forever启动服务端\n通过node的服务需要保证控制台连接，如果关掉控制台，服务就停了\n> node ./app.js\n\nforever是nodejs的守护进程，可以在后台运行\n安装forever\n> npm i forever -g\n\n启动服务\n> forever  start ./app.js\n\n## 通过阿里云控制台开启80端口与3000端口\n1. 进入云服务器控制台找到对应的安全组\n![ECS1.png](http://101.133.143.249:3000/api/getImage/ECS1.png)\n2.手动添加，配置对应的安全组\n![ECS2.png](http://101.133.143.249:3000/api/getImage/ECS2.png)\n\n\n# 结束\n\n\n', 'wangxing', '1695560362750', '1709989365797', '1', '213wqrffd');
INSERT INTO `article` VALUES ('9abe749f-690c-4144-9532-ae6a4e4396cf', 'centos8上docker与docker-compose安装使用', '## 在centos8上安装docker\n\n1. 安装依赖包\n\n> yum install -y yum-utils\n\n2. 设置镜仓库（默认是国外仓库，下载非常慢）\n\n> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n3. 更新yum\n\n> yum makecache\n\n4. 安装docker\n\n> yum install docker-ce docker-ce-cli containerd.io\n\n6. 启动docker\n\n> systemctl start docker\n\n7. 查看是否启动成功\n\n> docker version\n\n8. docker常用命令\n\n> 启动docker：systemctl start docker\n> 停止docker：systemctl stop docker\n> 重启docker：systemctl restart docker\n> 查看docker状态：systemctl status docker\n> 开机启动：systemctl enable docker\n> 当前系统docker信息：docker info\n> 列举出所有的容器：docker ps -a\n> 停止容器：docker start 容器ID或容器名\n> 直接关闭容器：docker kill 容器ID或容器名\n> 重启容器：docker restart 容器ID或者容器名\n> 删除容器：docker rm 容器ID或者容器名\n> 查看镜像：docker images\n\n## 如何使用阿里云提供的私人镜像仓库\n\n**背景：**由于目前国内的docker镜像仓库全部被封杀，如果我们需要把自己本地打包好的镜像上传到云服务器（不使用xftp这种手动方式），需要使用阿里云提供的私仓镜像服务\n\n参考\n[使用阿里云免费的Docker私有仓库](https://garywu520.github.io/2019/12/11/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%8D%E8%B4%B9%E7%9A%84Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/)\n[官方：容器镜像服务](https://cr.console.aliyun.com/repository/cn-shanghai/shenjipo/study01/details)\n\n1. 登录阿里云Docker Registry\n\n> docker login --username=shenjipo registry.cn-shanghai.aliyuncs.com\n\n用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。\n\n2. 从Registry中拉取镜像\n\n> docker pull registry.cn-shanghai.aliyuncs.com/shenjipo/study01:[镜像版本号]\n\n3. 将镜像推送到Registry\n\n> docker login --username=shenjipo registry.cn-shanghai.aliyuncs.com\n> docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/shenjipo/study01:[镜像版本号]\n> docker push registry.cn-shanghai.aliyuncs.com/shenjipo/study01:[镜像版本号]\n\n## 卸载docker\n\n> yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate dokcer-logrotate docker-engin\n\n卸载docker-ce（ce代表社区版）\n\n> yum remove docker-ce docker-ce-cli containerd.io\n\n删除docker资源\n\n> rm -rf /var/lib/docker\n\n## 安装docker-compose(国内)\n\n使用pip3安装 python3自带\n\n> yum -y install epel-release\n>\n> pip3 install docker-compose\n\n是否安装成功docker-compose(查看版本信息)\n\n>  docker-compose version\n\n卸载docker compose\n\n> rm /usr/local/bin/docker-compose\n\n参考 https://www.cnblogs.com/yyee/p/15731800.html\n', 'wangxing', '1720014895482', '1729693583998', '1', '213wqrffd');
INSERT INTO `article` VALUES ('9cacb2c0-ab46-41bd-aa7c-f4b22fb79e79', 'pnpm修改淘宝源', '# 查看源\npnpm get registry \n# 持久修改源\npnpm config set registry http://registry.npmmirror.com\n\n# 还原\npnpm config set registry https://registry.npmjs.org', 'wangxing', '1696560406785', '1709909497999', '1', '213wqrffd');
INSERT INTO `article` VALUES ('a9d32e82-37dc-4171-850e-74ce338e2ffe', 'centos8桌面版安装', '## centos8 yum设置为阿里源\n1、将源文件备份\n> cd /etc/yum.repos.d/ && mkdir backup && mv *repo backup/ \n\n2、下载阿里源文件\n> curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo\n\n3、更新源里面的地址\n> sed -i -e \"s|mirrors.cloud.aliyuncs.com|mirrors.aliyun.com|g \" /etc/yum.repos.d/CentOS-*\nsed -i -e \"s|releasever|releasever-stream|g\" /etc/yum.repos.d/CentOS-*\n\n4、生成缓存\n> yum clean all && yum makecache\n\n## 安装vscode\n启用 VS Code 仓库然后运行 yum 命令安装 vscode。\n1. 运行 rpm 命令导入 Microsoft GPG 密钥。\nrpm --import https://packages.microsoft.com/keys/microsoft.asc\n2. 完成后保存文件并退出vim文本编辑器。然后运行命令 sudo yum install code 安装Vscode\nvim /etc/yum.repos.d/vscode.repo\n```bash\n[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\n```\n3. 安装\n> yum install code\n\n## 安装git \n**signature hdr data: BAD, no. of btyes(9088) out of range   问题排查与解决方案**\n1. 在使用yum工具安装git的时候，报出了signature hdr data: BAD, no. of btyes(9088) out of range 的问题，这是由于centos8中rpm工具存在的一个bug，在校验安装包头部大小的时候，应当限制为64M，但是实际限制了64k，这个问题存在于 rpm-4.14.3-4.el8.x86_64 等版本，查看你本机的rpm版本可以使用命令\n> rpm -q rpm\n2. 解决方案，更新rpm版本\n>  dnf install tpm2-tss-2.3.2-3.el8.x86_64\ndnf install rpm-4.14.3-26.el8.x86_64\n\n3. 安装git\n> yum install git --nogpgcheck\n\n4. 查看git版本\n> git -v\n\n## 安装nvm\n1. 安装\n> curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash\n2. 验证是否成功（需要重启terminal）\n> nvm -v\n3. 安装指定版本node\nnvm i v16.15.0\n4. 安装pnpm\n> npm install -g pnpm\npnpm config set registry http://registry.npmmirror.com // 换源\n\n## 安装jdk17\n1.查找可安装的OPENJDK\n> yum search java | grep -i --color openjdk\n2. 选择安装java-17-openjdk.x86_64\n> yum install java-11-openjdk.x86_64 -y\n3. 切换默认使用的openjdk版本\n> alternatives --config java\n\n## 安装python3\n> yum install python3\n查看安装的版本\n> python3 -V\n\nhttps://stackoverflow.com/questions/55763428/react-native-error-enospc-system-limit-for-number-of-file-watchers-reached\n\n* insert the new value into the system config\n> echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p\n\n* check that the new value was applied\n> cat /proc/sys/fs/inotify/max_user_watches\n\n\n\n\n\n\n\n', 'wangxing', '1710943551591', '1711271219651', '1', '213wqrffd');
INSERT INTO `article` VALUES ('afc57d42-9b48-4b86-aa1a-ebd96ff9a72e', '仿jira管理系统', '## 基础元素\n\n自定义字段（级联、下拉、文本、富文本、数字）\n\n自定义任务项（意向、需求、子系统任务、缺陷）\n\n自定义工作流（提出、分析、评审、开发中、冒烟测试、系统测试、验收通过、完成、取消）\n\n自定义视图/看板（字段筛选器）\n\n自定义空间\n\n## 关系\n\n字段是最基础的元素，一些重要的、常用的字段被归类为系统级字段、剩下的是普通字段，所有的系统级字段和一些普通字段组成了任务项，任务项包含了若干个状态，在不同状态可以对字段的显示/编辑进行控制，不同状态之间可以进行流转，流转的过程也可以配置，包含以下几个配置项\n\n* 哪些状态可以流转到哪些状态、\n* 流转的前置条件、验证条件、后处理、\n* 流转视图字段显示/必填配置\n\n一个完整的工作流被称为任务项\n', 'wangxing', '1731678190747', '1731679894379', '2', '213wqrffd');
INSERT INTO `article` VALUES ('b1ac7515-8d16-4143-907a-e87617c4e64b', 'pnpm包管理工具', '# pnpm包管理工具的包存储路径修改\n安装了pnpm之后，pnpm会有个默认的包路径，有些文件夹由于权限的原因当前账户没有读写权限，会导致pnpm i安装失败，比如再公司的电脑上，这时需要修改pnpm安装包的路径，指定到有权限的文件夹来解决这个问题。\n查看当前的默认安装路径\n> pnpm config get store-dir\n\n![image.png](http://101.133.143.249:3000/api/getImage/image_f2b3bd7b-9c1a-436d-a36d-7cd69f668c2a.png)\n设置新的安装路径\n> pnpm config set store-dir D:\\document\\pnpm\n\n查看新的安装路径是否生效\n> pnpm store path\n\n![image.png](http://101.133.143.249:3000/api/getImage/image_bda84610-c577-44bf-8c47-18b910aff94b.png)\n\n# pnpm与npm的对比\npnpm基于硬连接和软连接来引入依赖的包，而npm通过复制文件来引入第三方包，因此pnpm能够节省磁盘的空间\n\n## 什么是硬连接和软连接？\n硬连接就是一个文件的索引（指针），指向了文件在磁盘系统中实际存储的位置，软连接就是文件索引的索引，指向了一个硬连接。\n同一块存储区域可以被多个索引指向，删除其中一个索引不会影响到其它索引，例如有硬连接A和B同时指向了0xaabbfff0，软连接C指向了B，那么删除了B，仍然能够通过A访问到存储的内容，但是无法通过C访问到存储的内容。\n\n* 硬连接只能用于文件，软连接可用于文件和文件夹。\n\nwindows Vista操作系统开始，支持了创建硬链接的操作，在cmd中使用下面的命令可以创建硬链接\n`mklink /h  链接名称  目标文件`\n例如我们先创建一个文件article.txt，写入内容`1123`\n![image.png](http://101.133.143.249:3000/api/getImage/image_385b0d00-f776-4d1d-9a24-613001966389.png)\n然后执行如下命令\n`mklink /h link.txt article.txt`\n可以看到多出了一个文件 link.txt\n![image.png](http://101.133.143.249:3000/api/getImage/image_5fee1fca-85a3-4f94-8932-d1a566cec3f8.png)\n\n修改article.txt文件的内容，link.txt的内容会一起变化，说明他们指向的是同一块地址\n![image.png](http://101.133.143.249:3000/api/getImage/image_09408452-d167-4def-bbed-b28b3f1afbb9.png)\n\nwindows Vista操作系统开始，支持了创建符号链接的操作\n`mklink  /d   链接名称   目标文件`\n/d表示创建的是目录的符号链接，不写则是文件的符号链接\n\n\n# pnpm构建过程\n假设我们的工程为proj，直接依赖a，a又依赖b\n1. 通过package.json查询依赖关系，得到最终要安装的包：a和b\n2. 在工程proj根目录中查看a和b是否已经有缓存，如果没有，下载到缓存中，如果有，则进入下一步\n3. 在proj中创建 node_modules 目录，从缓存的对应包中使用硬链接放置文件到相应包代码目录中\n![image.png](http://101.133.143.249:3000/api/getImage/image_094510ab-b760-4e2a-8729-58c2e82b15ee.png)\n4. 使用符号链接，将每个包的直接依赖放置到自己的目录中，保证a的代码在执行过程中，可以读取到直接依赖\n![image.png](http://101.133.143.249:3000/api/getImage/image_2da56b70-5073-4478-9d29-2ded247a3406.png)\n5. 在工程的node_modules目录中使用符号链接，放置proj项目的直接依赖\n![image.png](http://101.133.143.249:3000/api/getImage/image_88e09403-e510-4093-ba81-0ca4f65c78a4.png)\n\n\n总结：pnpm构建时，所有依赖的包都会在.pnpm/node_modules/resistry.xxx+package_name+version/目录下通过硬连接生成所有依赖的包文件，而这些包依赖的文件又是通过软连接构建的，对于project项目直接依赖的包，会在node_modules/目录下通过软连接连接到，避免了文件的复制节省了磁盘空间。\n![image.png](http://101.133.143.249:3000/api/getImage/image_e389f0c1-9311-474f-ab0d-de9d888ee3e6.png)', 'wangxing', '1696467785511', '1701181865755', '1', '213wqrffd');
INSERT INTO `article` VALUES ('c214223a-840f-4121-a262-0343a8bd9f5c', 'redis&rabbitmq学习', '# redis\n## linux安装redis\nyum install redis\n* 启动redis服务端 redis-server\n* 启动redis客户端 redis-cli\n* 使用配置文件启动redis  redis-server /etc/redis.conf\n\n## 修改redis配置文件\n由于redis默认关闭了网络连接方式（默认只允许使用127.0.0.1方式连接），所以需要修改配置文件，加入redis连接密码，才能进行网络连接，修改如图所示两行即可。\n![image.png](http://101.133.143.249:3000/api/getImage/image_57b9a1a5-003b-47fe-84d1-2e39a32bccc9.png)\n\n## 使用redis-insight连接redis\n\n\n\n## linux安装rabbitmq\n[rabbitmq安装包地址](https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.11.28)\n[erlang安装包地址](https://binaries2.erlang-solutions.com/centos/esl-erlang-25/esl-erlang_25.2.3_1~centos~8_x86_64.rpm)\nrabbitmq运行依赖于erlang环境，官网下载rpm文件手动安装时注意rabbitmq要求的erlang的版本号与操作系统的版本号，需要满足三个都是相同环境的才行，本文安装的rabbitmq版、erlang版本、操作系统版本如图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_8f65afac-87ae-4f7e-be2c-0c8b69441fb9.png)\n* 安装erlang环境 rpm -ivh esl-erlang_25.2.3_1~centos~8_x86_64.rpm\n* 安装socat yum install socat\n* 安装rabbitmq rpm -ivh rabbitmq-server-3.11.28-1.el8.noarch.rpm\n安装的过程中无报错，到此安装完成，下面是一些常用命令\n* 开机启动 chkconfig rabbitmq-server on\n* 启动rabbitmq /sbin/service rabbitmq-server start\n* 查看rabbitmq状态 /sbin/service rabbitmq-server status\n* 停止rabbitmq /sbin/service rabbitmq-server stop\n* 安装web管理插件 (安装时需要停止rabbitmq) rabbitmq-plugins enable rabbitmq_management (访问web管理后台地址 http://192.168.200.131:15672/)\n\n* 创建账号 rabbitmqctl add_user admin 123456\n* 设置账号角色 rabbitmqctl set_user_tags admin administrator\n* 设置用户权限 rabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\"\n（set_permissions [--vhost <vhost>] <username> <conf> <write> <read>）\n* 列出所有用户 rabbitmqctl list_users\n\n\n\n', 'wangxing', '1719497446685', '1719736276938', '1', '213wqrffd');
INSERT INTO `article` VALUES ('cbb2b1de-25bc-4c5f-8cf1-2124231cf434', '计划做的事', '1. 申请域名\n2. 服务端渲染\n3. 容器部署', 'wangxing', '1701608754676', '1701608754676', '2', '213wqrffd');
INSERT INTO `article` VALUES ('cbf1eb8b-beff-4798-931f-3898985fa967', '如何使用docker容器部署一个nginx服务，并支持多个web服务', '## docker安装的过程参考\n[centos8上docker安装使用(结合阿里云提供的私人镜像)](http://101.133.143.249/Blog/#/MainPage/BlogUpdate/9abe749f-690c-4144-9532-ae6a4e4396cf)\n\n## 使用docker部署nginx优势\n1. docker 能够屏蔽不同操作系统的差异，使用**同一个镜像+同一个命令**可以在多个系统上直接启动一个nginx服务\n2. 方便nginx的版本控制，容器的销毁与创建对于宿主机没有任何影响，不用担心卸载不干净\n\n## docker部署nginx的过程\n1. 编写构建镜像的Dockerfile配置文件\n我们使用官方提供的基础nginx镜像制作一个自己的ng镜像文件，制作镜像的Dockefile文件**Dockerfile.nginx**配置如下：\n```shell\n\n# 使用官方nginx镜像作为基础镜像  \nFROM nginx:alpine  \n    \n# 暴露80端口  \nEXPOSE 80  \n    \n# 默认情况下，nginx的配置文件已经足够用于静态文件服务  \n# 因此，这里不需要显式地复制配置文件，除非你有特殊需求  \n  \n# 启动nginx  \nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n2. 构建镜像，\n> docker build -f Dockerfile.nginx -t ng:latest\n\n3. 将镜像打包成tar包\n由于国内的docker镜像全部被封杀，我们需要把镜像打包成.tar文件上传到阿里云服务器。（阿里云提供的私仓镜像并不比打成tar包更便捷）\n> docker save -o ng.tar ng:latest\n\n4. 使用xshell把tar包上传到阿里云服务器\n5. 加载镜像 \n> docker load -i ng.tar\n6. 在 **/opt** 文件夹下生成html文件夹并创建nginx.conf文件，用作容器的外部映射卷，结果如图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_9d717c4d-7c23-4d45-9147-755fd8d7670c.png)\n8. 基于第5步加载的镜像启动ng容器\n> docker run --name ng -d -p 80:80 -v /opt/nginx.conf:/etc/nginx/nginx.conf:ro  -v /opt/html:/usr/share/nginx/html:ro ng\n\n解释下这个命令\n* -- name指定了启动的容器名称\n* -d 后台启动\n* -p 80(外部端口):80(内部端口) 把外部80端口映射到内部80端口 \n* -v /opt/nginx.conf(外部文件):/etc/nginx/nginx.conf(内部文件):ro 以只读模式把外部文件映射到内部文件\n* 最后一个ng就是镜像的名称\n', 'wangxing', '1721221962304', '1721223207561', '1', '213wqrffd');
INSERT INTO `article` VALUES ('cf7466d7-5fd6-4b75-a230-6fc5d2877f3a', '基于element-plus组件库的二次开发(Vue3.0)', '# 修改后的源码地址\n\n[二次开发的源码](https://github.com/shenjipo/el-cool)\n\n# 目标\n\n修改el-plus源码，将组件库的名称改为el-cool，添加函数式打开el-dialog的能力，并且发布到npm仓库，能够通过`npm i el-cool`安装\n\n# 准备工作(环境)\n\n* [el-plus源码地址](https://github.com/element-plus/element-plus.git)\n* [本文源码](https://github.com/shenjipo/el-plus-study03)\n* 参考资料 [打包循环引用修复](https://github.com/element-plus/element-plus/pull/16874/files)\n* node版本 `16.14.0` pnpm版本`8.15.4`\n\n接下来先验证源码编译没有问题\n\n1. `pnpm i`安装依赖\n2. `pnpm run dev`运行本地测试环境，成功之后如图所示\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_bda8fe5a-7ff5-4249-b297-8580a1975453.png)\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_12c5a1e4-486c-4d72-b022-fa08e39cfb48.png)\n3. `pnpm run build`本地打包，打包过程中会发现有如下循环引用报错，根据[这个issue](https://github.com/element-plus/element-plus/pull/16874/files)可以修复这个问题\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_7144807b-095e-41d7-9b8a-513845acd561.png)\n   修改的三个文件路径\n\n> packages\\components\\config-provider\\src\\config-provider-props.ts\n> packages\\hooks\\use-empty-values\\index.ts\n> packages\\components\\config-provider\\src\\hooks\\use-global-config.ts\n> 具体如何修改，看issue详情\n\n4. 然后重新打包，可以看到循环引用的错误提示没了，准备工作完成，下面开始修改源码\n\n# 修改过程\n\n## 编写弹窗工具类\n\n再`packages\\utils\\`路径下新建文件`CommonUtils.ts`，内容如下\n\n```javascript\nimport { h, render } from \'vue\'\n\nexport default class CommonUtils {\n    static context: any\n    static coms: Array<any> = []\n    static InitUtils(context: any) {\n        CommonUtils.context = context\n    }\n    static copy(val: any) {\n        return JSON.parse(JSON.stringify(val))\n    }\n\n    static TsDialog(component: any, config: Record<string, any>) {\n        const div = document.createElement(\'div\');\n        document.body.appendChild(div);\n        component.appContext = CommonUtils.context\n\n        const container = h(component, {\n            ...config,\n            hide: () => {\n                const destroyDiv = CommonUtils.coms.pop()\n                if (destroyDiv) {\n                    document.body.removeChild(destroyDiv)\n                }\n                const dom = document.querySelector(\'.el-overlay\')\n                if (dom) {\n                    document.body.removeChild(dom)\n                }\n\n            }\n        })\n        container.appContext = CommonUtils.context\n        render(container, div)\n        CommonUtils.coms.push(div)\n    }\n}\n```\n\n## 在入口文件导出CommonUtils，如图所示\n\n![image.png](http://101.133.143.249:3000/api/getImage/image_a83124e2-dcf3-4a49-8a49-8467d9a6e744.png)\n![image.png](http://101.133.143.249:3000/api/getImage/image_73fe796d-b56c-408a-bccd-f1456a879fde.png)\n\n## 使用自动化脚本生成弹窗组件\n\n进入目录\n\n> D:\\document\\research\\el-plus-series\\element-plus\\scripts\n\n右键 git bash here打开shell窗口，执行`bash gc.sh WrapperDialog`，可以看到自动生成的组件\n![image.png](http://101.133.143.249:3000/api/getImage/image_50571095-41eb-48c5-8f2a-16100ff83dac.png)\n\n## 修改弹窗组件\n\n修改这两个文件即可`WrapperDialog.vue`和`WrapperDialog.ts`，具体修改看源码\n\n## 导出弹窗组件\n\n![image.png](http://101.133.143.249:3000/api/getImage/image_0a3e0918-c215-47f0-a58a-4c54057d359d.png)\n\n## 注册弹窗组件-调用Vue.use(ElementPlus)后，能够自动注册该组件\n\n![image.png](http://101.133.143.249:3000/api/getImage/image_bfabda48-25f8-4430-8467-0eb81fcded88.png)\n\n## 修改组件库名称为el-cool\n\n这一块的改动设计到上千个文件，重点涉及到以下一些文件夹\n\n![image_236966c954167fe23fa4f570a7d3b02f.png](http://101.133.143.249/api/getImage/image_236966c954167fe23fa4f570a7d3b02f.png)\n\n![image_a46ac0384bd6654529af1c98dc34a66c.png](http://101.133.143.249/api/getImage/image_a46ac0384bd6654529af1c98dc34a66c.png)\n\n![image_efd446472b4f631ede3da7d5949b3dd4.png](http://101.133.143.249/api/getImage/image_efd446472b4f631ede3da7d5949b3dd4.png)\n\n![image_7a97b39581551945881649dd338e1f33.png](http://101.133.143.249/api/getImage/image_7a97b39581551945881649dd338e1f33.png)\n\n# 验证是否成功\n\n1. 使用`npm i el-cool`安装依赖\n   ![image_9903533d0f919119f77baad0a6570cff.png](http://101.133.143.249/api/getImage/image_9903533d0f919119f77baad0a6570cff.png)\n2. 按照源码修改组件代码，\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_36b4b6a9-373f-4ce2-817e-5e85ac0f5747.png)\n   实现如下效果，点击确定按钮，出现第一个弹窗\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_b9ea5bb6-eb01-42a0-a37e-55d604272e7f.png)\n   点击确定，出现第二个弹窗\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_1b35b0c1-9b2b-4687-90af-bb0fb2952bb7.png)\n   点击取消，关闭第二个弹窗\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_2865a462-7806-4829-8075-e33002ef4eea.png)\n   点击取消，关闭第一个弹窗\n   ![image.png](http://101.133.143.249:3000/api/getImage/image_ef40ee31-c870-4972-a2f7-e4b732ddb440.png)\n', 'wangxing', '1717420638137', '1730638528192', '1', '213wqrffd');
INSERT INTO `article` VALUES ('d099a3af-d244-4b71-b448-7364e7e31608', '如何在Vue-cli与Vite项目中配置代理解决跨域问题', '## Vue2cli配置代理\n**注意** 如果前端服务在8080端口启动，那么必须把axiost的`baseURL`地址配置成`localhost:8080`，向别的端口请求数据被不会本地服务器代理\n`vue.config.js`配置\n```javascript\nmodule.exports = {\n    lintOnSave: false,\n    publicPath: \'/Blog/\',\n    devServer: {\n        proxy: {\n            \'/api\': {\n                target:\'http://localhost:3000\',\n                changeOrigin:\'true\', // 允许跨域\n\n            }\n        }\n    }\n}\n```\n`axios`配置\naxios里面连接服务器的地址，代理后要改成本地地址\n```javascript\nconst service: AxiosInstance = axios.create({\n    baseURL: \'/api\', // http:localhost:3000/api  这种写法无法被代理\n    timeout: 30000\n})\n```\n\n## vite配置代理\n配置注意点同上\n`vite.config.js`\n```javascript\nexport default defineConfig({\n  plugins: [vue()],\n  base: \'/AttackSpeed/\',\n  server: {\n    host: \'0.0.0.0\',\n    port: 8080,\n    open: true,\n    proxy:{\n      \'/api\':{\n        target:\'http://localhost:3000\',\n        changeOrigin:true\n      }\n    }\n  }\n})\n```\n`axios.js`\n```javascript\nconst service = axios.create({\n    baseURL: \'/api\',\n    timeout: 30000\n})\n```\n', 'wangxing', '1697698048708', '1697939157834', '1', '213wqrffd');
INSERT INTO `article` VALUES ('d12ff33b-dd8d-4c20-a1c8-a3f503c875f5', 'linx(centos8)及其常用软件的常用命令', '# nvm\n## 列出所有已经安装的版本\n> nvm -ls\n\n# nginx\n* 启动nginx \n>systemctl start nginx.service\n* 停止Nginx \n> systemctl stop nginx.service\n* 重启Nginx \n> systemctl restart nginx.service\n* 查看Nginx状态 \n> systemctl status nginx.service\n\n \n\n# 进程\n* 查看当前进程占用的端口 \n> netstat -ntlp\n\n* 杀死进程 \n> kill pid\n\n* 后台执行node进程 \n> nohup npm run serve > test.log & exit\n\n* 退出node后台 使用下面的命令查询出相关进程，全部杀死进程即可\n> ps -ef|grep node\n\n# 防火墙\n* 查看防火墙状态 \n> systemctl status firewalld\n* 开机关闭防火墙 \n> systemctl disable firewalld\n* 关闭防火墙 \n> systemctl stop firewalld', 'wangxing', '1710339274971', '1721223462105', '1', '213wqrffd');
INSERT INTO `article` VALUES ('d1c3fe65-8eed-4338-82a3-e99339270b35', 'Cookie的使用', '# cookie的用途\n通常用于\n1. 用户身份（权限）识别\n2. 多平台单点登陆（需要后端配合）\n3. 用户身份解析\n\n# 如何使用cookie\ncookie的配置基本通过后端的响应头来实现，前端的操作空间比较小，因此cookie的安全性较高，但是不够灵活，前端开发还是要了解cookie的基本属性，这样才能好排查一些问题。\n\n首先通过f12打开控制台，找到application-cookie，可以看到cookie具有以下几个属性\n* name \n* value：cookie的最基本属性，cookie以key-value形式存储\n* Domain：配置cookie作用于哪个域名下，注意点如下\n1. 在setcookie中省略domain参数，那么domain默认为当前域名。\n2. domain参数可以设置父域名以及自身，但不能设置其它域名，包括子域名，否则cookie不起作用。\n假设有以下三个域名 `zydya.com` `blog.zyday.com` `one.blog.zyday.com`\n在`zydya.com`域名下设置的cookie只能作用在`zydya.com` 域名下\n在`blog.zyday.com`的域名下设置的cookie可以作用在`blog.zyday.com`也可以作用在`zydya.com`域名下\n在`one.blog.zyday.com`的域名下设置的cookie可以作用在`one.blog.zyday.com`  `blog.zyday.com` `zydya.com`域名下。\n\n√表示该域名下能取到cookie，×表示不能取到cookie\n在zyday.com域名下设置cookie，做四次测试\n|domain参数|zydya.com|blog.zydya.com|one.blog.zydya.com\n|-|-|-|-|\n|setcookie(\'name\',1,time()+1)|√|√|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'zyday.com\')|√|√|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'blog.zyday.com\')|×|×|×|\n|setcookie(\'name\',1,time()+1,\'/\',\'one.blog.zyday.com\')|×|×|×|\n\n然后在blog.zyday.com域名下设置cookie，测试条件同上\n|domain参数|zydya.com|blog.zydya.com|one.blog.zydya.com\n|-|-|-|-|\n|setcookie(\'name\',1,time()+1)|×|√|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'zyday.com\')|√|√|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'blog.zyday.com\')|×|√|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'one.blog.zyday.com\')|×|×|×|\n\n最后在one.blog.zyday.com域名下设置cookie\n|domain参数|zydya.com|blog.zydya.com|one.blog.zydya.com\n|-|-|-|-|\n|setcookie(\'name\',1,time()+1)|×|×|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'zyday.com\')|√|√|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'blog.zyday.com\')|×|√|√|\n|setcookie(\'name\',1,time()+1,\'/\',\'one.blog.zyday.com\')|×|×|√|\nset-cookie只能往自己的域名以及父域名上设置，前端请求携带的cookie只能是自身域名下的以及父域名下的\n* Path 设置cookie在某一个域名下作用的路径，通常就是`/`，匹配该域名下的所有请求路径\n* Expires/Max-age 设置cookie过期时间\n* size cookie的大小\n* HttpOnly 如果为true，那么前端`document.cookie`无法操作cookie\n* Secure 表示这个 Cookie 仅能用 HTTPS 协议加密传输\n* SameSite 设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接`跨站`发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。\n\n# 如何跨域请求时携带cookie\n注意这里的跨域携带cookie适用如下场景\n例如当前用户在workbench.fat.qa.com域名下，向lingdong.fat.qa.com发送了一个一个xhr请求-http://lingdong.fat.qa.com/getUserInfo，默认情况下，该请求不会携带cookie，但是，可以设置`withCredentials`属性为true，使得该请求能够自动带上lingdong.fat.qa.com域名下的cookie\n**注意**\n1. 无论如何，向lingdong.fat.qa.com域名发送的请求无法带上workbench.fat.qa.com域名下的cookie\n2. 后端还需要在http://lingdong.fat.qa.com/getUserInfo接口的响应头中配置跨域响应头（不能为*）\nAccess-Control-Allow-Origin: http://workbench.fat.qa.com\n3. 后端还要配置`Access-Control-Allow-Credentials`响应头为true。\n4. lingdong.fat.qa.com域名下的cookie SameSite属性不能为Strict\n\n# 跨域与跨站区别\nCookie中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可\n\n举几个例子，www.taobao.com 和 www.baidu.com 是跨站，www.a.taobao.com 和 www.b.taobao.com 是同站，a.github.io 和 b.github.io(.github.io是顶级域名) 是跨站(注意是跨站)。\n\n根据 跨域 和 跨站 定义的 不同，我们可以知道 跨站一定跨域，但是跨域不一定跨站。\n\nwithCredentials属性值和samesite值会出现冲突，此时谁的权重更高呢？答案是存在的，此时以samesite为主。举个例子：在a.demo2.com域名下，ajax请求a.demo.com的api，此时是跨站 且跨域 的，需要设置withCredentials才能带上cookie.`但如果此时cookie中的samesite值为Lax或Strict,此ajax请求是不能携带cookie的。`\n\n# samesite对于跨站请求的影响\n在chrome80版本以上的浏览器中，SameSite默认为Lex，默认开启了跨站cookie拦截。如果我们有网站A`aaa.bbb.ccc.com`与网站B`aaa.bbb.ddd.com`，需要通过iframe在网站A中内嵌网站B，由于浏览器跨站cookie的拦截策略，以iframe嵌入的网站B的所有请求都无法携带域名`aaa.bbb.ddd.com`下的cookie，造成接口访问401问题，那么如何解决？\n1. 手动开启浏览器允许跨站cookie，浏览器地址栏输入`chrome://flags`，搜索`same-site-by-default-cookies`和`cookies-without-same-site-must-be-secure`，设置为`disabled`重启浏览器生效，此方法通常适合用于本地调试，\n2. `aaa.bbb.ddd.com`服务端切换到https协议，同时后端响应头设置为`cookie=xxx;SameSite=None;Secure`\n3. 切换到同站的域名,`aaa.bbb.ddd.com`切换到`xxx.ccc.com`格式的域名，此域名与`aaa.bbb.ccc.com`不跨站，cookie不会被拦截。\n\n# 基于cookie设计一个单点登录系统\n基于cookie实现的单点登录系统优缺点如下：\n优点：安全性高，由浏览器来负责cookie的安全性，前端代码几乎不需要做任何改造，（仅仅需要在后端返回401状态码时跳转到登陆页面），主要工作由后端实现。\n缺点：灵活性较差，例如当你想对各个系统做微前端改造时，由于前端无法获取cookie，实现起来较为困难。\n\n实现思路：基于cookie来鉴定用户身份，xx应用的后端接口进行权限校验，如http请求未携带cookie信息，则返回401，如果携带cookie信息，则调用登陆服务进行cookie有效性校验，如果无效，则返回401，如果正常就返回正常的数据。前端判断如果出现401状态码，就跳转到登陆接口，并且携带一个callbackurl，用于登陆成功或者cookie单点校验成功的回跳。登陆系统进行cookie单点校验，如果在别的系统登陆过了，就通过设置302响应跳回去，并且设置在响应头设置cookie，如果没有登陆，就跳转到统一登陆的前端页面，由用户输入账号密码，如果成功，则跳回到callbackurl地址。\n\n登陆的时序图\n![登陆时序图.png](http://101.133.143.249:3000/api/getImage/ç»éæ¶åºå¾_ab6d119b-735c-452a-97d5-862374a66694.png)', 'wangxing', '1699881176473', '1703079927227', '1', '213wqrffd');
INSERT INTO `article` VALUES ('df840cb4-663a-48d0-b0be-4ec162bd82c6', 'arco-design风格的element-ui组件', '使用方法\n\n![image_d890fd4189ddfd404edf3d930bde06db.png](http://101.133.143.249/api/getImage/image_d890fd4189ddfd404edf3d930bde06db.png)\n\n**el-arco.scss**文件内容\n\n```scss\n$--color-primary: #5599ff;\n$--color-white: #ffffff;\n$--color-black: #000000;\n$--color-success: #00b42a;\n$--color-warning: #ff7d00;\n$--color-danger: #f53f3f;\n$--color-info: #86909c;\n\n$--color-text-primary: #1d2129;\n$--color-text-regular: #1d2129;\n$--color-text-secondary: #6b7785;\n$--color-text-placeholder: #86909c;\n\n$--border-color-base: #e5e6eb;\n$--border-color-light: #e4e7ed;\n$--border-color-lighter: #ebeef5;\n$--border-color-extra-light: #f2f6fc;\n\n$--background-color-base: #f2f6fc;\n\n$--border-radius-base: 0px;\n$--border-radius-small: 0px;\n$--border-radius-4: 4px;\n$--border-width-base: 1px;\n$--border-width-secondary: 1px;\n$--border-secondary: $--border-width-secondary solid #dcdfe6;\n\n$--box-shadow-base: 0 4px 10px rgba(0, 0, 0, .1);\n$--checkbox-input-border: $--border-secondary;\n$--select-dropdown-empty-color: #a9aeb8;\n$--msgbox-border-radius: 0px;\n$--message-background-color: #fff;\n$--message-padding: 10px 16px 10px 16px;\n$--notification-radius: 4px;\n$--notification-shadow: 0 4px 12px raba(0, 0, 0, .15);\n$--tag-border-radius: 2px;\n$--table-row-hover-background-color: #f7f8fa;\n\n// input\n$--input-backgound-color: $--background-color-base;\n// pagination\n$--pagination-border-radius: 2px;\n\n/* 改变 icon 字体路径变量，必需 */\n$--font-path: \'~element-ui/lib/theme-chalk/fonts\';\n@import \"../../node_modules/element-ui/packages/theme-chalk/src/index.scss\";\n```\n', 'wangxing', '1730896268357', '1731398883000', '1', '213wqrffd');
INSERT INTO `article` VALUES ('e225ac1c-8ea3-41f0-ba6b-3e8fdae7dd88', '年度账单动画/一镜到底动画 如何实现(基于pixijs)', '# 源码\n[年度账单源码](https://github.com/shenjipo/pixijs-study)\n# 账单动画介绍\n年度账单从交互上可以分为两种\n1. 翻页的动画，每页都会独立展示，不会同时展示多页。\n2. 一镜到底的动画，每页都是连起来的，看着是一个整体，实际是一个超长的或者超高的动画，通过用户的滑动，展示这个动画不同的部分。\n\n无论你哪种动画，pixijs主要提供以下几个能力帮助我们开发\n1. 普通图片资源预加载，提供加载进度与加载完成的回调函数\n2. 纹理图的解析，能够直接解析“纹理打包器Texture Packer”输出的JSON文件\n3. 图片的定位，缩放，旋转，移动，交互事件\n4. 提供适配移动端的能力（提升canvas清晰度）\n\n下面具体介绍这两种动画的开发思路\n# 一镜到底动画\n推荐个视频资源 [一镜到底动画-B站](https://www.bilibili.com/video/BV1FZ4y1M7w5/?spm_id_from=333.337.search-card.all.click)\n\n1. UI在设计一个超长的图片，如下图所示\n![image.png](http://101.133.143.249:3000/api/getImage/image_4a211964-ef13-435c-97b4-b3d3df4644c1.png)\n2. 对图片进行分镜，如下图分成了3个镜头，根据UI提供的素材，算好这3个镜头所在的平面坐标，以x和y来表示，例如第一张图片的其实坐标为(0,0)，pixijs默认右上角为0，0。第二张图的坐标为(0,640)，假设每个镜头的图片高度都为640px，第三张图片坐标为(0,640*2)\n![image.png](http://101.133.143.249:3000/api/getImage/image_4fb78c0b-d7b1-4371-a451-b1088d158784.png)\n3. UI根据切分的镜头进行图片的裁剪，得到3张小图片\n ![image.png](http://101.133.143.249:3000/api/getImage/image_56d89419-a18c-48a9-9325-0eb34d523c67.png)\n4. 使用pixijs加载这些图片，并且根据之前的坐标确定他们的位置\n```javascript\n// 0.设置舞台，pixijs生成的canvas加载到某个dom元素上\n document.getElementById(\'stage\').appendChild(app.view)\n// 1.加载图片\n    let imgs = [\n        \'imgs/bg@1x_1.png\',\n        \'imgs/bg@1x_2.png\',\n        \'imgs/bg@1x_3.png\',\n    ]\nPIXI.loader\n    .add(imgs)\n    .on(\'progress\', function (loader, resource) {\n        // 加载完一张图片，这个函数会被调用一次，loader.progress获取当前图片资源加载进度\n        console.log(loader.progress)\n        $(\'#loadingProgress\').html(Math.round(loader.progress) + \'%\')\n    })\n    .load(setup)//所有图片加载完会调用这个函数\n// 2. 设置10个场景的位置，10个分镜准备放到这个10个场景中\n        app = new PIXI.Application({\n            width: width,\n            height: height\n        })\n        // 生成的canvas渲染到dom上\n        document.getElementById(\'stage1\').appendChild(app.view)\n        // 创建一个大舞台 \n        let spriteGroupSences = new PIXI.Container()\n        spriteGroupSences.position.set(0, 0)\n        spriteGroupSences.name = \'spriteGroupSences\'\n        app.stage.addChild(spriteGroupSences)\n        // 创建三个分镜头的舞台\n        let sence1 = new PIXI.Container()\n        sence1.position.set(0, 0)\n        sence1.name = \'sence1\'\n        let sence2 = new PIXI.Container()\n        sence2.position.set(0, 640)\n        sence2.name = \'sence2\'\n        let sence3 = new PIXI.Container()\n        sence3.position.set(0, 640 * 2)\n        sence3.name = \'sence3\'\n        spriteGroupSences.addChild(sence1)\n        spriteGroupSences.addChild(sence2)\n        spriteGroupSences.addChild(sence3)\n\n        // 分镜头图片加入到对应的分舞台\n        let img1 = new PIXI.Sprite.fromImage(imgs[0])\n        app.stage.getChildByName(\'spriteGroupSences\').getChildByName(`sence1`).addChild(img1)\n        let img2 = new PIXI.Sprite.fromImage(imgs[1])\n        app.stage.getChildByName(\'spriteGroupSences\').getChildByName(`sence2`).addChild(img2)\n        let img3 = new PIXI.Sprite.fromImage(imgs[2])\n        app.stage.getChildByName(\'spriteGroupSences\').getChildByName(`sence3`).addChild(img3)\n```\n5. 设置总时间轴，监听用户的滑动，控制时间轴（y轴）的前进与后退，使用AlloyTouch库实现\n```javascript\n// 监听滑动事件\n        let maxLong = -(640 * 2)\n        //总时间轴\n        let allTimeline = new TimelineMax({ paused: true })\n        function touchAction() {\n            //seek progress\n            let alloyTouch = new AlloyTouch({\n                touch: \'body\',\n                vertical: true,//控制动画水平/垂直方向的滑动\n                maxSpeed: 0.8,\n                max: 0,\n                min: maxLong,\n                bindSelf: false,\n                initialValue: 0,\n                change: function (value) {\n                    if ((value <= 0) && (value > maxLong)) {\n                        let progress = value / maxLong\n                        console.log(value, progress)\n                        allTimeline.seek(progress)\n                    }\n                }\n            })\n        }\n```\n6. 设置子时间轴，根据滑动位置，来控制动画的变化，一个时间轴可以加入多个子时间轴，方便再滑动的过程中加入不同的动画\n```javascript\n        //子时间轴 TweenMax \n        function tweenAction() {\n            // 获取pixijs的舞台\n            let sences = app.stage.getChildByName(\'spriteGroupSences\')\n            // 生成一个子时间轴，从时间轴为0时启动，delay范围从0-1，小数\n            let sencesTimeline = new TimelineMax({ delay: 0 })\n            // 建一个从当前属性到指定目标属性的TweenMax动画对象，y从0到 640*2 动画持续时间整个的时间轴长度(参与为1的含义，如果一般时间轴就是0.5)，\n            // 在滑动过程中，TweenMax会根据当前滑动比例，自动去更改sences.position的y属性，从而实现动画效果\n            console.log(sences.position)\n            let sencesTween = TweenMax.to(sences.position, 1, { y: maxLong })\n            // 动画加入子时间轴\n            sencesTimeline.add(sencesTween, 0)\n            // 子时间轴加入总时间轴\n            allTimeline.add(sencesTimeline, 0)\n        }\n```\n7. 实现的效果,通过鼠标控制滑动动画，其他动画根据类似过程，加入子时间轴就可以了\n![image.png](http://101.133.143.249:3000/api/getImage/image_cfed1d61-37d6-416a-b84e-a224b6834011.png)\n\n# 翻页动画\n翻页动画的处理更为简单，我们仅需要pixijs提供的2D图片渲染能力以及原生的css动画就可以实现，下面是制作翻页动画的步骤\n1. 根据UI设计的分镜头设置一些div元素，不展示的dom元素使用`display: none`隐藏\n```html\n    <div id=\"stage1\">\n        <div class=\"stage1-text1\">正在穿越中...</div>\n        <div class=\"stage1-text2\"></div>\n    </div>\n\n    <div id=\"stage2\" class=\"no-show\">\n        <div class=\"stage2-text1 no-show\"></div>\n        <div class=\"stage2-dialog no-show\">\n            <p class=\"stage2-dialog-text\"></p>\n        </div>\n    </div>\n\n    <div id=\"stage3\" class=\"no-show\">\n        <div class=\"stage3-text1 no-show\"></div>\n        <div class=\"stage3-echarts no-show\"></div>\n    </div>\n```\n2. 设置监听用户滑动的事件，移动端使用`touchstart` `touchmove` `touchend`实现，PC端使用`mouseclick` `mousemove`实现，在后面会详细介绍\n3. 利用pixijs提供的舞台渲染函数实现翻页\n```javascript\n    function startPage3(forward, page) {\n        // 切换到这一页时，需要清除掉前一页或者后一页的所有动画\n        if (forward) {\n            app.stage.getChildByName(\'spriteGroupSences\').getChildByName(`sence${page - 1}`).children = []\n        } else {\n            app.stage.getChildByName(\'spriteGroupSences\').getChildByName(`sence${page + 1}`).children = []\n        }\n 	// 这一页的div元素正常显示，并且把舞台渲染上去\n        $(\'#stage3\').removeClass(\'no-show\')      \n        document.getElementById(\'stage3\').appendChild(app.view)\n        // 设置这一页的背景图片\n        spr = new PIXI.Sprite.fromImage(scene3_imgs[0])\n        spr = setBgPos(spr)\n        spr.name = \'sence3\'\n        let sprites = app.stage.getChildByName(\'spriteGroupSences\').getChildByName(\'sence3\')\n        sprites.addChild(spr)\n    }\n```\n\n# 注意点\n## pixijs在移动端生成的canvas或者img标签展示的图片很糊怎么解决？\n首先说原因，因为图片的像素和手机的物理像素点没有一一对应，手机端自动进行了填充，所以看起来很糊。如何解决？让UI给我们切设计稿的2倍图\n这个博客说的也比较清楚\n[移动端开发为什么使用@2x@3x图片](https://www.cnblogs.com/HuiTaiLang1216/p/15971286.html)\n\nimg标签的解决办法：假设设计稿的尺寸是100*50，那么2倍图就是200*100，在使用的时候仍然设置img标签为100*50，但是引入的是2倍图@2x.png\n\npixijs的canvas解决办法：,设置resolution分辨率为2倍，生成的canvas也是个2倍的canvas，然后通过resize去适应我们手机的逻辑像素。**此方法需要pixijs版本大于5.2.1**\n```javascript\n        #stage1 {\n            height: 100vh;\n            width: 100vw;\n            position: relative;\n            overflow: hidden;\n        }\n        width = document.getElementById(\'stage1\').clientWidth\n        height = document.getElementById(\'stage1\').clientHeight\n        app = new PIXI.Application({\n            width: width,\n            height: height,\n            resolution: 2,// 关键\n            antialias: true,\n        })\n        app.renderer.autoDensity = true;\n        // 关键\n        app.renderer.resize(width, height);\n```\n## 移动端和PC端如何监听用户的上滑和下滑事件？\n移动端\n```javascript\n    // 滑动监听事件\n    let [endY, diff] = [0, 0]\n\n    let curPage = 2 // 当前页数\n    let PageL = 10 // 最大页数\n    document.body.addEventListener(\"touchstart\", touchStart, { passive: false });\n    document.body.addEventListener(\"touchmove\", touchMove, { passive: false });\n    document.body.addEventListener(\"touchend\", touchEnd, { passive: false });\n    function touchStart(e) {\n        var touch = e.touches[0];\n        startY = touch.pageY;\n    }\n    function touchMove(e) {\n        //e.preventDefault();\n        var touch = e.touches[0];\n        endY = touch.pageY;\n        diff = endY - startY;\n    }\n\n    function touchEnd(e) {\n        // diff 负数往下滑动\n        if (Math.abs(diff) > 10 && canTouch) {\n            if (diff > 0) {\n                // 向前翻页\n                if (curPage <= 1) {\n                    return;\n                }\n                curPage--;\n            } else {\n                // 向后翻页\n                if (curPage >= PageL) {\n                    return;\n                }\n                curPage++;\n            }\n\n        }\n    }\n```\nPC端\n```javascript\nwindow.addEventListener(\'mousedown\', mousedown)\nwindow.addEventListener(\'mouseup\', mouseup)\nlet currY = 0\nfunction mousedown(e){\n    currY = e.y\n}\nfunction mouseup(e){\n    if(e.y - currY > 50){\n        curPage--    \n    }else if(e.y - currY < -50){\n        curPage++\n    }\n}\n```\n## pixijs容器的精灵如何清除？\n```javascript\n    // 清楚指定的单个精灵\n    sprites = app.stage.getChildByName(\'spriteGroupSences\').getChildByName(\'sence1\')\n    sprites.removeChild(cloud_left)\n    // 清楚所有精灵\n    app.stage.getChildByName(\'spriteGroupSences\').getChildByName(`sence1`).children = []  \n```\n', 'wangxing', '1699885107225', '1701836709248', '1', '213wqrffd');
INSERT INTO `article` VALUES ('ecd624cd-7921-4397-aad3-3be19783c165', 'ElementUI组件一些常见的坑', '项目源码地址\nhttps://github.com/shenjipo/Element-ui\n\n# 一.如何像message弹窗一样，通过js编程生成一个dialog\n原生的`element-ui`组件中官方推荐我们通过绑定`dialogVisiable`来控制弹窗的的显示与关闭，但是这会造成两个问题\n1. dialog组件中可能也有很复杂的逻辑，把dialog组件的业务代码和控制它的组件的业务代码混合在一起不利于维护，使得一个组件的代码行数过多\n2. 一个组件可能含有多个不同的弹窗，业务逻辑混合在一起\n3. 弹窗组件绑定的数据大多数时候并不需要和控制弹窗的组件一起加载，而是在打开弹窗的时候再去请求对应的数据，原有的使用方式不方便控制数据加载的时机，如果我们在弹窗显示时候再去加载，经常会看到一打开页面报各种`undfined`错误\n\n**如何解决**：通过js语言，动态的去加载弹窗组件，加载的时候传递弹窗组件需要的数据，在弹窗组件内部通过props接收\n**实现思路**：利用`Vue.extend`API生成一个vue子类的构造函数，通过此构造函数生成vue组件实例，通过该实例对象的`$mount`方法将组件挂在到`body`下面\n```javascript\n// 弹窗工具类\nimport Vue from \"vue\";\n\nexport default function JsDialog(options: any, propsData: any = {}) {\n    const div = document.createElement(\'div\');\n    const el = document.createElement(\'div\');\n    div.appendChild(el);\n    document.body.appendChild(div);\n    // vue.extend 生成一个Vue子类的构造函数\n    const dialogConstructor = Vue.extend(options)\n    // 通过构造函数 生成vue组件实例，,通过propsData传递的参数在组件中可以通过props接收到\n    let instance: any = new dialogConstructor({ propsData })\n    instance.show = () => {\n        instance.$mount(el)\n    }\n    instance.destroy = () => {\n        if (instance) {\n            instance.$destroy();\n            instance = null\n            div.parentNode && div.parentNode.removeChild(div);\n        }\n    }\n    // vue组件内置的发布订阅函数，once仅监听一次，在dialog组件中，通过emit可以触发此事件   \n    instance.$once(\'hide\', () => {\n        if (instance) {\n            instance.$destroy();\n            instance = null\n            div.parentNode && div.parentNode.removeChild(div);\n        }\n    })\n    return instance\n} \n```\n\n``` javascript\n// 弹窗子组件\n<template>\n    <el-dialog title=\"提示\" :visible.sync=\"dialogVisible\" width=\"30%\">\n        span\n        <span slot=\"footer\" class=\"dialog-footer\">\n            <el-button @click=\"handleCancel\">取 消</el-button>\n            <el-button type=\"primary\" @click=\"handleConfirm\">确 定</el-button>\n        </span>\n    </el-dialog>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Prop } from \'vue-property-decorator\';\n@Component({\n    components: {\n    },\n})\nexport default class SettingDialog extends Vue {\n    dialogVisible: boolean = true\n    gridData: Array<any> = []\n    @Prop() data: any\n    @Prop() onConfirm: any\n    handleCancel() {\n	// 关闭弹窗\n        this.$emit(\'hide\')\n    }\n    handleConfirm() {\n        console.log(\'从父组件接收的参数\', this.data)\n        // 把处理好的数据传递给父组件\n        this.onConfirm(this.gridData)\n        // 关闭弹窗\n        this.$emit(\'hide\')\n    }\n}\n</script>\n// 父组件使用\n  handleClick() {\n    // 第一个参数是要打开的弹窗组件，第二个参数是要传递给该组件的参数\n    JsDialog(SettingDialog, {\n      data: this.data,\n      onConfirm: (data: any) => {\n        // 处理弹窗确认逻辑\n        console.log(\'从dialog接收的参数\', data)\n      }\n    }).show()\n  }\n```\n\n# 二.如何修改dialog、popever等不在id为app的div下的元素的样式\n由于vue `scoped`作用限制，无法在修改不在`app`下面的元素样式\n![image.png](http://8.130.116.190:3000/api/getImage/image_40cff9a0-2027-48d7-85d6-cfa297f27862.png)\n通过`custom-class`属性给dialog最外层的dialog添加class去掉scoped，在全局样式中直接修改元素样式\n``` css\n<style lang=\"scss\">\n.custom-select {\n    .el-select-dropdown__list {\n        .el-select-group__wrap:first-child {\n            max-height: 150px;\n            overflow-y: auto;\n            overflow-x: hidden;\n            padding-bottom: 0;\n\n        }\n        .el-select-group__wrap:first-child::after {\n            display: none;\n        }\n        .el-select-group__wrap:last-child::before {\n            content: \'\';\n            position: absolute;\n            display: block;\n            left: 20px;\n            right: 20px;\n            top: 2px;\n            height: 1px;\n            background-color: #e4e7ed;\n        }\n    }\n}\n</style>\n```\n\n# 日期选择器常见的快捷选择方式(依赖于moment库)\n\n\n\n# 三.级联选择器如何实现同级多选\n思路：使用vue的watch函数监听选中的值变化，对比新值与旧值，找出新选中的子项，计算子项所在的层级，与之前保存的层级对比，如果相同，就不做处理，如果不同，清楚原先选中的子项，把新的子项作为选中的值，并且更新层级\n```html\n	// emitPath必须设置false，只获取子节点的值\n        <el-cascader v-model=\"value\" :options=\"options\" :props=\"{ multiple: true, checkStrictly: true, emitPath: false }\"\n            :show-all-levels=\"false\" clearable></el-cascader>\n```\n\n```javascript\n    // 监听选中的值的变化\n    @Watch(\'value\')\n    watchSelectValue(newValue: Array<string>, oldValue: Array<string>) {\n\n        if (newValue.length > oldValue.length) {\n            let newSelect: string = newValue.filter((item) => {\n                return !oldValue.includes(item)\n            })[0]\n\n            let newDepth = this.getDepth(newSelect, this.options, 0)\n           \n            if (newDepth !== this.curDepth) {\n                this.curDepth = newDepth\n                this.value = [newSelect]\n            }\n\n        }\n    }\n    // 获取当前子项所在的组织树的层级\n    getDepth(key: string, orgTree: Array<any>, curLevel: number): number {\n\n        for (let i = 0; i < orgTree.length; i++) {\n            if (orgTree[i].value === key) {\n                return curLevel\n            } else if (orgTree[i].children) {\n                let temp = this.getDepth(key, orgTree[i].children, curLevel + 1)\n                if (temp !== -1) {\n                    return temp\n                }\n            }\n        }\n        return -1\n\n    }\n```\n\n\n\n# 四.el-select带防抖的远程搜索怎么写\n使用select远程搜索时，需要处理以下问题\n1. 当初次输出时，由于输入的内容较少，后端查询以及网络请求需要的时间较多，随着用户的输入变多，请求响应越来越快，最早发出的请求可能会最晚回来，覆盖掉请求结果，因此用户的输入需要防抖，当在一定时间内，检测到用户再次输入时，取消前面的请求。\n2. 由于`el-options`的数据是从后端返回的，因此当我们选择好了一些数据，再次打开下拉框时，会发现，只显示`value`值了，无法显示完整的数据，所以需要把`label`和`value`都存下来(这一点根据实际清空自己实现)\n\n\n**html代码**\n\n```html\n        <el-select v-model=\"value\" placeholder=\"请选择\" popper-class=\"remote-select\" multiple filterable\n            :filter-method=\"handleRemote\" :loading=\"repoLoading\" style=\"width: 400px;\">\n\n            <el-option v-for=\"item in repoOptions\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\">\n            </el-option>\n\n        </el-select>\n```\n**js代码**\n```javascript\n    repoOptions: Array<{ key: string, value: string, label: string }> = [\n\n    ]\n    repoLoading: boolean = false\n    value: string = \'\'\n    timer: any = null\n    handleRemote(query: string) {\n        if (query !== \'\') {\n            this.repoLoading = true\n            this.timer && clearTimeout(this.timer)\n\n            this.timer = setTimeout(() => {\n                this.mockApi().then((res: any) => {\n                    this.repoOptions = res.data.map((item: any) => {\n                        return {\n                            value: item.value,\n                            label: `${item.value}(${item.key})`,\n                            key: item.key\n                        }\n                    })\n                    this.repoLoading = false\n                }).catch(err => {\n                    this.repoLoading = false\n                })\n            }, 500)\n        }\n    }\n```\n\n此外，如果这个模糊接口的速度较慢，例如后端请求的返回时间最长超过2s，那么随着用户的输入，网络请求的速度会越来月刊，先发出请求返回的数据可能晚于后发出的请求，因此需要一个请求时间戳来表示请求发出的时间，从而防止数据被覆盖掉。这可以通过axios的config参数实现\n\naxios设置\n```javascript\naxiostInstance.get(url, {params: netId}).then(res => {\n    res.data.netId = res.config.params\n    return res\n})\n\n```\nvue组件使用\n```javascript\nhandleRemote(query: string) {\n        if (query !== \'\') {\n            this.repoLoading = true\n            this.timer && clearTimeout(this.timer)\n	    this.netId = new Date().getTime()\n            this.timer = setTimeout(() => {\n                this.mockApi().then((res: any) => {\n                    if(res.netId === this.netId){\n                        // 业务逻辑\n                    }\n                   \n                    this.repoLoading = false\n                }).catch(err => {\n                    this.repoLoading = false\n                })\n            }, 500)\n        }\n    }\n\n```\n\n# 五.el-select如何改造，可以固定一部分选项在底部\n首先实现的效果\n![image.png](http://8.130.116.190:3000/api/getImage/image_40979cc4-80aa-40d6-a6f8-bb1fb7991ca4.png)\n只有上面的一部分有滚动条，下面的部分是固定的\n实现思路，通过css样式给滚动条的第一个group设置最大高度，并且添加y轴的滚动条，通过伪元素after与before添加分割线与去除位置不对的分割线\n**注意** **必须通过`popper-class`属性给弹出的下拉框设置class，同时在不带scoped的style标签中去修改样式，这是因为弹窗默认加在了body下面，与div(id=app)平级，在vue的scope样式中无法穿透到\n代码**\n```html\n// html部分\n        <el-select v-model=\"value\" placeholder=\"请选择\" popper-class=\"custom-select\">\n            <el-option-group v-for=\"group in options\" :key=\"group.label\" >\n                <el-option v-for=\"item in group.options\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\">\n                </el-option>\n            </el-option-group>\n        </el-select>\n// 数据部分\n    options: any = [\n        {\n            label: \'aaa\',\n            options: [{\n                value: \'Chengdu\',\n                label: \'成都\'\n            }, {\n                value: \'Shenzhen\',\n                label: \'深圳\'\n            }, {\n                value: \'Guangzhou\',\n                label: \'广州\'\n            }, {\n                value: \'Dalian\',\n                label: \'大连\'\n            }, {\n                value: \'2\',\n                label: \'大连1\'\n            }, {\n                value: \'3\',\n                label: \'大连2\'\n            }, {\n                value: \'4\',\n                label: \'大连3\'\n            }]\n        },\n        {\n            label: \'bbb\',\n            options: [{\n                value: \'manage\',\n                label: \'仪表盘管理\'\n            }, {\n                value: \'create\',\n                label: \'新建仪表盘\'\n            }]\n        }\n    ]\n    value: string = \'Guangzhou\'\n// css样式部分\n<style lang=\"scss\">\n.custom-select {\n    .el-select-dropdown__list {\n        .el-select-group__wrap:first-child {\n            max-height: 150px;\n            overflow-y: auto;\n            overflow-x: hidden;\n            padding-bottom: 0;\n\n        }\n        .el-select-group__wrap:first-child::after {\n            display: none;\n        }\n        .el-select-group__wrap:last-child::before {\n            content: \'\';\n            position: absolute;\n            display: block;\n            left: 20px;\n            right: 20px;\n            top: 2px;\n            height: 1px;\n            background-color: #e4e7ed;\n        }\n    }\n}\n</style>\n```', 'wangxing', '1696987096339', '1698031570752', '1', '213wqrffd');
INSERT INTO `article` VALUES ('f78057d0-4e07-4859-b9e5-edea9854fac6', '工作台', '[工作台](http://101.133.143.249/workbench/#/)', 'wangxing', '1708345692246', '1708345692246', '1', '213wqrffd');
INSERT INTO `article` VALUES ('faceae0f-6305-49a9-a6b6-f6c10586bb94', 'centos7.5安装MySql8', '# 安装mysql8\n```shell\nyum install mysql\nyum install mysql-devel\n// 安装mysql-server\nwget http://dev.mysql.com/get/mysql80-community-release-el7-5.noarch.rpm\nrpm -ivh mysql80-community-release-el7-5.noarch.rpm\nyum install mysql-community-server\n// 最后一步执行失败报错 GPG check FAILED 执行以下命令\nyum install mysql-community-server --nogpgcheck\n```\n# 安装后启动mysql服务\n```shell\nservice mysqld restart\n\n# 登录mysql并输入密码\nmysql -u root -p\n\n# mysql8 修改密码方式\nalter user \'root\'@\'localhost\' identified by \'这里填你要的密码\';\n```\n**注意**\n> mysql8初次安装后，需要先通过`cat /var/log/mysqld.log | grep password` 命令查看密码，修改密码时，需要 符合长度，且含有数字、小写或大写字母、特殊字符\n# 配置远程连接授权设置（配置后即可用navicat建立连接）\n```shell\n# 修改密码规则 （解决低版本的navicat连接mysql8报错的问题）报错信息如下\n# Client does not support authentication protocol requested by server; consider upgrading MySQL client\nALTER USER \'root\'@\'localhost\' IDENTIFIED WITH mysql_native_password BY \'你的密码\';\n# 授权，以root账户为例\nGRANT ALL PRIVILEGES ON *.* TO \'root\'@localhost WITH GRANT OPTION;\n# 刷新权限\nFLUSH PRIVILEGES;\n```\n# navicat远程连接设置\n1.配置数据库的账号和密码\n![image.png](http://101.133.143.249:3000/api/getImage/image_d919309e-9e36-46d2-90bd-8a4d14c41238.png)\n2.配置阿里云的地址和账号密码\n![image.png](http://101.133.143.249:3000/api/getImage/image_28a28424-3a93-400b-a89a-56e7fd6e9786.png)\n3.配置阿里云的安全组\n![image.png](http://101.133.143.249:3000/api/getImage/image_63448c60-cb72-47e2-9b85-bc2c3a366f40.png)\n![image.png](http://101.133.143.249:3000/api/getImage/image_c185c204-4796-4702-b8ab-41f4294cd836.png)', 'wangxing', '1696464335521', '1709984081022', '1', '213wqrffd');
INSERT INTO `article` VALUES ('ff5b72df-3dd4-49a2-a9e4-0c624687970d', '基于element-ui开发组件库-vue2.0', '## 本博客源码\n[efforless-ui](https://github.com/shenjipo/effortless-ui)\n\n## 目标\n基于element-ui二次开发组件库，并且将改造完的组件库上传到npm`仓库，能够使用npm i xxx的方式直接使用\n## 相关参考\n* [element-ui组件库源码](https://github.com/ElemeFE/element)\n* [element-ui文件结构介绍](https://juejin.cn/post/6935977815342841892)\n* [TypeScript声明文件/语法介绍](https://ts.xcatliu.com/basics/declaration-files.html#%E4%B9%A6%E5%86%99%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6)\n* [package.json文件配置](https://docs.npmjs.com/cli/v10/configuring-npm/package-json#files)\n\n## element-ui目录结构介绍\nel文件结构如图，介绍下其中的重要的文件或者文件夹\n![image.png](1)\n1. `build`，el实现工程化的文件放在这里，\n   * `build/bin`中存放了一些js脚本文件，通过node xxx.js可以执行这些文件，自动生成一些文件放在src或者packages文件夹下，例如组件导入导出的入口文件，新组件的基础模板文件。\n   * `build/loader`中实现了兼容vue语法的md语法编译器，能够把写了vue语法的md文件编译成vue的模板文件，官方的文档就是用这个写的，按照一定的规则，你可以再md中使用vue的语法。\n   * `webpack.*.js`这一类的文件配置了如何编译打包，包括打生产包，打dev包，还有打官网的静态资源包。\n2. `examples`和`src`组件的具体实现就在这两个文件夹下\n3. `lib`打好的包就在这下面，我们在自己的项目中`import ElementUI from \'element-ui\'`引入的就是这里的文件，虽然安装的时候会带上`src`和`packages`，这主要是给人看的，并不会实际被引入到项目中。\n4. `types`各个组件的类型文件，配合ts项目使用\n5. `Makefile`make工具的自动化脚本文件，在mac和linux系统上可以通过make xxx命令来执行我们提前配置好的node命令，在windows上我们直接看对应的命令是啥，然后去手动执行就行了。例如`make install`实际执行的就是`npm install` \n![image.png](http://101.133.143.249:3000/api/getImage/image_13d15fa9-c919-4b46-8b55-e9973b186b97.png)\n6. `package.json`，npm的配置文件，其中\n    * `name`和`version`配置了这个包的名称和版本，名称在npm仓库中必须唯一，版本一般从1.0.0开始，规则可以参考[版本号规则](http://101.133.143.249/Blog/#/Preview/PreviewBlog/28743c58-77d5-4549-9f84-1071cfa65821)\n    * `files`配置了通过npm i xxx安装本项目时所包含的文件，默认包含了package.json\n    * `typings`告诉了ts编译器类型文件的入口\n    * `scripts`配置了一些可执行命令\n    * `main` 配置当别人使用import或者require()导入这个项目时的入口文件\n\n## 源码的修改\n### 目标-添加函数式打开弹窗的能力\nel组件整体的设计思路是通过工程化的方式自动生成一些组件导入导出的文件、组件模板文件。方便开发者只需要关心具体组件的实现，而不需要去手动修改其它文件使得新加入的组件能够被使用到。因此我们按照作者的设计思路来添加新的组件。\n\n本次修改需要添加一个新的弹窗组件和一个新的弹窗工具函数，实现能够通过js命令`CommonUtils.JsDialog(MyDialog,{}).show()`打开一个新的弹窗，当关闭弹窗时自动销毁这个弹窗，这样做的原因参考[el原生弹窗使用的问题](http://101.133.143.249/Blog/#/Preview/PreviewBlog/ecd624cd-7921-4397-aad3-3be19783c165)。\n\n### 准备工作\n1. 在修改源码之前，先将node版本切换到14.x，本人使用的是14.17.0\n2. 执行npm run dev:play\n3. 打开`localhost:8085`看到这个说明依赖安装没问题\n![image.png](http://101.133.143.249:3000/api/getImage/image_b00a7958-066e-44ed-b0dd-7c58f476ddd6.png)\n\n### 修改包名\n1. 全局替换`element-ui`为`effortless-ui`，包含的文件\n> src/,packages/,package.json,web-types.json,\n![image.png](http://101.133.143.249:3000/api/getImage/image_e58f7943-8aa7-49df-a113-c91af8b36a7b.png)\n2. 修改别名配置，`build/config.js`\n3. 修改打包后的入口文件名 `build/webpack.common.js`\n\n### 添加新的工具函数\n1. 在`src/utils`下面新建`CommonUtils.js`，具体代码参考https://github.com/shenjipo/effortless-ui\n2. 关闭eslint校验 `.eslintignore`\n```shell\nsrc/utils/popper.js\nsrc/utils/date.js\nsrc/utils/lodash.js\nsrc/utils/CommonUtils.js\nexamples/play\npackages/\n*.sh\nnode_modules\nlib\ncoverage\n*.md\n*.scss\n*.woff\n*.ttf\n```\n3. 修改`build-entry`，使得自动生成的`src/index.js`能够导出`CommonUtils`\n4. 在`examples/play.js`中看下CommonUtils有没有被导出，\n> console.log(Element);\n5. 重新执行npm run dev:play\n6. 打开浏览器看到这个就可以了\n![image.png](http://101.133.143.249:3000/api/getImage/image_af9e4ebd-9180-44fd-b5b6-68e18c993e1a.png)\n\n### 添加新的组件\n1. 命令行node build/bin/new.js easy-dialog\n2. 修改`packages/easy-dialog/index.vue`下面的代码\n3. 新建`examples/play/SettindDialog.vue`，参考源码修改\n4. 修改`examples/play/index.vue`，参考源码修改\n5. 重新执行npm run dev:play,打开浏览器弹窗可以正常打开和关闭，并且显示内容\n![image.png](http://101.133.143.249:3000/api/getImage/image_c2a938c4-6eef-4b8d-97bc-17c42b6c9a56.png)\n\n### 为新的工具函数添加类型约束\n1. `types/index.d.ts`修改\n```typescript\nexport * from \'./effortless-ui\'\nimport * as EffortlessUI from \'./effortless-ui\'\nimport Vue, { PluginObject } from \'vue\'\nexport namespace CommonUtils {\n    function JsDialog(vue: typeof Vue, props: Record<string, any>): {\n        show: () => {}\n    }\n\n}\nexport default EffortlessUI\n```\n2. 修改 `types/index.d.ts`为`types/effortless-ui.d.ts`\n\n### 发布到npm仓库\n**npm publish知识**\n在package.json文件中，files属性用于指定当包被发布到npm仓库时应该包含哪些文件。这是一个数组，列出了相对于包根目录的文件或目录路径。\n\n当你运行npm publish时，npm会默认包括除了.git、node_modules、.npmignore文件中指定的内容（如果存在的话）以及某些其他默认忽略的文件（如.DS_Store等）之外的所有文件和目录。但是，如果你明确指定了files属性，npm将只包括files数组中列出的文件和目录。\n\n由于windows上无法执行shell脚本，所以我们自己使用npm命令来发布\n1. npm run dist打包\n2. 新建一个文件夹`MyUiComponent`，把`lib,packages,src,types,package.json`复制进去\n3. 注册npm账号，然后登陆，修改版本号为1.0.0然后**npm publish**\n\n## 验证包能否使用\n1. 在一个vue脚手架生成的项目执行`npm i effortless-ui`，\n2. 在`main.ts`中修改\n```typescript\nimport \'effortless-ui/lib/theme-chalk/index.css\';\nimport EffortlessUI from \'effortless-ui\'\nVue.use(EffortlessUI)\n```\n\n3. 在`src/components`中新建MyDialog.vue，具体代码参考源码\n4. 在`src/HelloWorld.vue`中验证 CommonUtils，具体代码参考源码\n5. npm run serve启动，如图弹窗可以弹出和销毁\n![image.png](http://101.133.143.249:3000/api/getImage/image_1ecf2285-4ea6-4380-934a-fd3f15f1eabc.png)\n6. 鼠标放到`JsDialog`上，可以看到ts的类型校验，而且我们在写代码时，会有自动提示的功能\n![image.png](http://101.133.143.249:3000/api/getImage/image_9a541efa-eff3-4e20-b29a-127975494c61.png)\n\n\n\n\n', 'wangxing', '1714909216587', '1717596620600', '1', '213wqrffd');

-- ----------------------------
-- Table structure for dashboard
-- ----------------------------
DROP TABLE IF EXISTS `dashboard`;
CREATE TABLE `dashboard`  (
  `id` int(0) UNSIGNED NOT NULL AUTO_INCREMENT,
  `author_uuid` varchar(99) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `create_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `update_time` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `custom` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `card_list` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 21 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of dashboard
-- ----------------------------
INSERT INTO `dashboard` VALUES (5, '213wqrffd', '1704375191907', '1721224175043', '{\"title\":\"测试1号\"}', '[{\"title\":\"基础折线图\",\"key\":0,\"i\":\"a561ad24-0674-4d47-9e2f-c1af3fa73925\",\"icon\":\"/imgs/LineChartBase.png\",\"class\":\"selected\",\"type\":0,\"w\":1,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":0,\"y\":0,\"moved\":false},{\"title\":\"基础平滑折线图\",\"key\":1,\"i\":\"a424b67b-22c7-41dd-82f0-8983d41fbcf5\",\"icon\":\"/imgs/LineChartSmooth.png\",\"class\":\"selected\",\"type\":1,\"w\":1,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":0,\"y\":6,\"moved\":false},{\"title\":\"基础平滑折线图\",\"key\":1,\"i\":\"b7069f86-d08f-47a9-81a3-5ee8ed198d8d\",\"icon\":\"/imgs/LineChartSmooth.png\",\"class\":\"selected\",\"type\":1,\"w\":1,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":1,\"y\":0,\"moved\":false},{\"title\":\"基础柱状图\",\"key\":2,\"i\":\"9657ba1f-3c5b-4d14-b78c-581b035262e3\",\"icon\":\"/imgs/BarChartBase.png\",\"class\":\"selected\",\"type\":2,\"w\":1,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":2,\"y\":0,\"moved\":false}]');
INSERT INTO `dashboard` VALUES (6, '213wqrffd', '1704375202825', '1705325512105', '{\"title\":\"测试2号\"}', '[{\"title\":\"基础折线图\",\"key\":0,\"i\":\"619202d9-d108-4494-b5b5-de1256e69693\",\"icon\":\"/imgs/LineChartBase.png\",\"class\":\"selected\",\"type\":0,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":0,\"y\":0,\"moved\":false},{\"title\":\"基础平滑折线图\",\"key\":1,\"i\":\"c2680670-d3d4-4de3-bea7-d0d8997999ac\",\"icon\":\"/imgs/LineChartSmooth.png\",\"class\":\"selected\",\"type\":1,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":2,\"y\":0,\"moved\":false},{\"title\":\"基础柱状图\",\"key\":2,\"i\":\"db0aad90-cb6a-469f-9588-ca324b082e45\",\"icon\":\"/imgs/BarChartBase.png\",\"class\":\"selected\",\"type\":2,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":0,\"y\":6,\"moved\":false},{\"title\":\"基础折线图\",\"key\":0,\"i\":\"9706ba3f-e36b-46e9-8565-4185aa1da5d5\",\"icon\":\"/imgs/LineChartBase.png\",\"class\":\"selected\",\"type\":0,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":2,\"y\":6,\"moved\":false},{\"title\":\"基础平滑折线图\",\"key\":1,\"i\":\"71a6cf12-3c57-43d1-aa1d-f26ef468406e\",\"icon\":\"/imgs/LineChartSmooth.png\",\"class\":\"selected\",\"type\":1,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":0,\"y\":12,\"moved\":false},{\"title\":\"带背景色的柱状图\",\"key\":3,\"i\":\"432f6280-bfbe-4f81-ba83-12ee2d74a464\",\"icon\":\"/imgs/BarChartBackground.png\",\"class\":\"selected\",\"type\":3,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":2,\"y\":12,\"moved\":false}]');
INSERT INTO `dashboard` VALUES (8, '213wqrffd', '1704633394456', '1704721092265', '{\"title\":\"仪表盘3号213\"}', '[{\"title\":\"基础折线图\",\"key\":0,\"i\":\"238c721a-8ac6-4503-8505-63ea501b31ef\",\"icon\":\"/imgs/LineChartBase.png\",\"class\":\"selected\",\"type\":0,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":0,\"y\":0},{\"title\":\"基础平滑折线图\",\"key\":1,\"i\":\"a919415e-f140-4912-a090-7b26f75e4b07\",\"icon\":\"/imgs/LineChartSmooth.png\",\"class\":\"selected\",\"type\":1,\"w\":2,\"h\":6,\"minH\":6,\"minW\":1,\"maxH\":8,\"maxW\":4,\"x\":0,\"y\":6}]');
INSERT INTO `dashboard` VALUES (9, '213wqrffd', '1704633398672', NULL, '{\"title\":\"仪表盘4号\"}', NULL);
INSERT INTO `dashboard` VALUES (10, '213wqrffd', '1704633403249', NULL, '{\"title\":\"仪表盘5号\"}', NULL);
INSERT INTO `dashboard` VALUES (11, '213wqrffd', '1704633410320', NULL, '{\"title\":\"仪表盘1号\"}', NULL);
INSERT INTO `dashboard` VALUES (12, '213wqrffd', '1704633414792', NULL, '{\"title\":\"仪表盘2号\"}', NULL);
INSERT INTO `dashboard` VALUES (13, '213wqrffd', '1704633419536', NULL, '{\"title\":\"仪表盘6号\"}', NULL);
INSERT INTO `dashboard` VALUES (14, '213wqrffd', '1704633423944', NULL, '{\"title\":\"仪表盘7号\"}', NULL);
INSERT INTO `dashboard` VALUES (15, '213wqrffd', '1704633428633', NULL, '{\"title\":\"仪表盘8号\"}', NULL);
INSERT INTO `dashboard` VALUES (16, '213wqrffd', '1704633433442', NULL, '{\"title\":\"仪表盘9号\"}', NULL);
INSERT INTO `dashboard` VALUES (17, '213wqrffd', '1704633437368', NULL, '{\"title\":\"仪表盘10号\"}', NULL);
INSERT INTO `dashboard` VALUES (18, '213wqrffd', '1704633442633', NULL, '{\"title\":\"仪表盘11号\"}', NULL);
INSERT INTO `dashboard` VALUES (19, '213wqrffd', '1704633449015', NULL, '{\"title\":\"仪表12号\"}', NULL);
INSERT INTO `dashboard` VALUES (20, '213wqrffd', '1704633453330', NULL, '{\"title\":\"仪表盘13号\"}', NULL);
INSERT INTO `dashboard` VALUES (21, '213wqrffd', '1704633458784', NULL, '{\"title\":\"仪表盘14号\"}', NULL);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `account` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `token` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `createTime` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `updateTime` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('213wqrffd', 'shenjipo', '15896302145.wx', '324', '1702390076182', '1702474798038');
INSERT INTO `user` VALUES ('e8e54989-296c-45f1-a67f-f60b2986cf8f', 'wangxing446', '15896302145.wx', NULL, '1702391943798', NULL);

SET FOREIGN_KEY_CHECKS = 1;
